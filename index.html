<!DOCTYPE html>
<html lang="fr">
  <meta charset="UTF-8">
  <!-- META TAGS PWA - √Ä ajouter juste apr√®s <meta charset="UTF-8"> -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LEGO Manager">
<meta name="theme-color" content="#d32f2f">

<!-- PWA MANIFEST -->
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="./icon-192.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tri Pi√®ces LEGO (Bulk Mode - IndexedDB)</title>
  <link rel="icon" href="data:,">


  <link rel="stylesheet" href="./styles.css">

  <style>

  </style>

<script src="./unified-data-manager.js"></script>
<script src="./debug.js"></script>
<script>
// D√©tection automatique du chemin de base
const BASE_PATH = window.location.pathname.includes('/lego-manager/') 
  ? '/lego-manager' 
  : '';

function navigateTo(page) {
  window.location.href = `${BASE_PATH}/${page}`;
}
</script>
</head>

<body>
  <div class="container">
    <h1>Mode vrac : Tri des pi√®ces LEGO (IndexedDB)</h1>
    
  <div id="file-manager" class="file-manager-section">
      <h3>Statut de la base de donn√©es LEGO (IndexedDB)</h3>
      <p>Cette application stocke les donn√©es dans IndexedDB pour g√©rer les gros volumes de donn√©es.</p>
      
      <!-- Statut de la base de donn√©es -->
      <div style="background: #f0f0f0; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">
        <strong>Base de donn√©es :</strong> <span id="db-status">Initialisation...</span>
      </div>
      
      <div class="file-status" id="file-status">
        <!-- Les statuts des fichiers seront affich√©s ici -->
      </div>
      
      <div class="upload-instructions">
        <h4>Instructions :</h4>
        <ol>
          <li>T√©l√©chargez les 4 fichiers CSV requis depuis Rebrickable :</li>
          <ul>
            <li><strong>parts.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/parts.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/parts.csv.gz</a></li>
            <li><strong>part_categories.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/part_categories.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/part_categories.csv.gz</a></li>
            <li><strong>inventory_parts.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/inventory_parts.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/inventory_parts.csv.gz</a></li>
            <li><strong>colors.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/colors.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/colors.csv.gz</a></li>
            <li><strong>sets.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/sets.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/sets.csv.gz</a></li>
            <li><strong>inventories.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/inventories.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/inventories.csv.gz</a></li>
            <li><strong>minifigs.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/minifigs.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/minifigs.csv.gz</a></li>
            <li><strong>inventory_minifigs.csv</strong> : <a href="https://cdn.rebrickable.com/media/downloads/inventory_minifigs.csv.gz" target="_blank">https://cdn.rebrickable.com/media/downloads/inventory_minifigs.csv.gz</a></li>

          </ul>
          <li>Si les fichiers sont compress√©s (.gz), d√©compressez-les avec 7-Zip, WinRAR ou un outil similaire</li>
          <li>Glissez-d√©posez les fichiers CSV d√©compress√©s dans la zone ci-dessous ou utilisez le bouton "Parcourir"</li>
          <li>Les fichiers seront analys√©s et stock√©s dans IndexedDB automatiquement</li>
          <li>Une fois les 3 fichiers charg√©s, le bouton "Lancer l'application" s'activera</li>
        </ol>
      </div>
      
      <div class="upload-area" id="upload-area">
        <p>Glissez-d√©posez vos fichiers CSV ici ou <button class="btn" onclick="document.getElementById('file-input').click()">Parcourir</button></p>
        <input type="file" id="file-input" multiple accept=".csv">
        <p><small>Fichiers accept√©s : parts.csv, part_categories.csv, inventory_parts.csv, colors.csv</small></p>
      </div>
      
      <div style="text-align: center; margin: 20px 0;">
        <button class="btn btn-warning" onclick="checkForUpdates()">V√©rifier les mises √† jour</button>
        <button class="btn" id="launch-app" onclick="launchApp()" disabled>Lancer l'application</button>
        <button class="btn btn-danger" onclick="clearAllData()">Effacer toutes les donn√©es</button>
      </div>
    </div>
    
    <!-- Section cach√©e pour redirection -->
    <div id="app" class="hidden">
      <div class="loading">Redirection vers l'application...</div>
    </div>
  </div>

 <!-- Inclure le fichier mutualis√© -->
  <script src="./lego-db.js"></script>

  <script>
    // Variables globales pour la gestion des fichiers
    let db = null;
    let csvWorker = null;


   window.onload = async function() {
  console.log('Initialisation de l\'application...');
  
  // Initialiser la base de donn√©es
  db = new window.LegoDatabase();
  await db.init();
  await db.verifyAndRepairStores();
  
  // Initialiser le worker CSV
  csvWorker = window.createCSVWorker();
  
  // Configurer l'interface
  renderInitialFileStatus();
  setupFileManager();
  await updateFileStatus();
  
  console.log('Application initialis√©e');
};

    function renderInitialFileStatus() {
      const statusDiv = document.getElementById('file-status');
      statusDiv.innerHTML = '';

      for (const fileKey of Object.keys(REQUIRED_FILES)) {
        const file = REQUIRED_FILES[fileKey];
        const fileDiv = document.createElement('div');
        fileDiv.className = 'file-item missing';
        fileDiv.id = `file-${fileKey}`;
        fileDiv.innerHTML = `
          <div class="file-name">${file.name}</div>
          <div class="file-status-text missing">‚ùå Manquant</div>
          <div>${file.description}</div>
          <a href="${file.url}" target="_blank" class="download-link">üì• T√©l√©charger</a>
          <div class="progress-bar" id="progress-${fileKey}" style="display:none;">
            <div class="progress-fill" id="progress-fill-${fileKey}"></div>
          </div>
        `;
        statusDiv.appendChild(fileDiv);
      }
    }

    // Configuration du gestionnaire de fichiers
    function setupFileManager() {
      const uploadArea = document.getElementById('upload-area');
      const fileInput = document.getElementById('file-input');
      
      uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });
      
      uploadArea.addEventListener('dragleave', function(e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
      });
      
      uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
      });
      
      fileInput.addEventListener('change', function(e) {
        handleFiles(e.target.files);
      });
    }

    // Mise √† jour du statut des fichiers
    async function updateFileStatus() {
      const launchBtn = document.getElementById('launch-app');
      let allFilesLoaded = true;

      for (const fileKey of Object.keys(REQUIRED_FILES)) {
        const fileDiv = document.getElementById(`file-${fileKey}`);
        const count = await db.getTableCount(fileKey);
        const fileDate = await db.getFileDate(fileKey); // R√©cup√©rer la date du fichier

        const isLoaded = count > 0;

        if (!isLoaded) allFilesLoaded = false;

       const fileDateText = fileDate ? new Date(fileDate).toLocaleDateString() : 'Date inconnue';

    fileDiv.className = `file-item ${isLoaded ? 'loaded' : 'missing'}`;
    fileDiv.querySelector('.file-status-text').textContent = isLoaded ? '‚úÖ Charg√©' : '‚ùå Manquant';
    fileDiv.querySelector('.file-status-text').className = `file-status-text ${isLoaded ? 'loaded' : 'missing'}`;

    if (isLoaded) {
      const existingButtons = fileDiv.querySelectorAll('.btn-danger, .update-button');
      existingButtons.forEach(btn => btn.remove());
      
      const countDiv = fileDiv.querySelector('.file-count');
      if (!countDiv) {
        fileDiv.innerHTML += `
          <div class="file-count">${count.toLocaleString()} enregistrements</div>
          <div class="file-count">Date du fichier: ${fileDateText}</div>
          <button class="download-link btn-danger" onclick="removeFile('${fileKey}')">üóëÔ∏è Supprimer</button>
        `;
      } else {
        countDiv.innerHTML = `${count.toLocaleString()} enregistrements<br>Date du fichier: ${fileDateText}`;
          }
        }
      }

      launchBtn.disabled = !allFilesLoaded;
      document.getElementById("db-status").textContent = allFilesLoaded
        ? "‚úÖ Base op√©rationnelle"
        : "‚ÑπÔ∏è Base partielle ou incompl√®te";
    }

    // Gestion des fichiers t√©l√©charg√©s
    async function handleFiles(files) {
      for (let file of files) {
        if (!file.name.endsWith('.csv')) {
          showErrorMessage(`Fichier ignor√©: ${file.name} (seuls les fichiers .csv sont accept√©s)`);
          continue;
        }
        
// D√©terminer le type de fichier bas√© sur le nom
let fileKey = null;
const lowerName = file.name.toLowerCase();

if (lowerName === 'parts.csv') {
  fileKey = 'parts';
} else if (lowerName === 'part_categories.csv') {
  fileKey = 'part_categories';
} else if (lowerName === 'inventory_parts.csv') {
  fileKey = 'inventory_parts';
} else if (lowerName === 'colors.csv') {
  fileKey = 'colors';
} else if (lowerName === 'sets.csv') {
  fileKey = 'sets';
} else if (lowerName === 'inventories.csv') {  // NOUVEAU
  fileKey = 'inventories';
} else if (lowerName === 'minifigs.csv') {  // NOUVEAU
  fileKey = 'minifigs';
} else if (lowerName === 'inventory_minifigs.csv') {  // NOUVEAU
  fileKey = 'inventory_minifigs';
}
        
        if (!fileKey) {
          showErrorMessage(`Type de fichier non reconnu: ${file.name}. Noms attendus: parts.csv, part_categories.csv, inventory_parts.csv, colors.csv`);
          continue;
        }
        
        await processFile(file, fileKey);
      }
      
      await updateFileStatus();
    }
  
async function processFile(file, fileKey) {
  const fileDiv = document.getElementById(`file-${fileKey}`);
  const progressBar = document.getElementById(`progress-${fileKey}`);
  const progressFill = document.getElementById(`progress-fill-${fileKey}`);

  try {
    fileDiv.className = 'file-item processing';
    fileDiv.querySelector('.file-status-text').textContent = '‚è≥ Lecture fichier...';
    fileDiv.querySelector('.file-status-text').className = 'file-status-text processing';
    progressBar.style.display = 'block';

    const text = await file.text();
    if (text.length < 100) throw new Error('Fichier trop petit ou vide');

    fileDiv.querySelector('.file-status-text').textContent = '‚è≥ Analyse CSV...';
    progressFill.style.width = '10%';

    // Analyser le CSV
    const data = await new Promise((resolve, reject) => {
      csvWorker.onmessage = (e) => {
        if (e.data.type === "progress") {
          progressFill.style.width = `${10 + e.data.value * 40}%`;
        } else if (e.data.type === "done") {
          resolve(e.data.data);
        }
      };
      csvWorker.onerror = (err) => reject(err);
      csvWorker.postMessage({ text });
    });

    if (data.length === 0) throw new Error('Aucune donn√©e valide trouv√©e');

    fileDiv.querySelector('.file-status-text').textContent = 'üì¶ Enregistrement DB...';
    progressFill.style.width = '60%';

    // Nettoyer les donn√©es selon le type
    let cleanedData = data;
    if (fileKey === "parts") cleanedData = window.cleanPartsData(data);
    if (fileKey === "inventory_parts") cleanedData = window.cleanInventoryPartsData(data);
    if (fileKey === "part_categories") cleanedData = window.cleanCategoriesData(data);
    if (fileKey === "colors") cleanedData = window.cleanColorsData(data);
    if (fileKey === "sets") cleanedData = window.cleanSetsData(data);
    if (fileKey === "inventories") cleanedData = window.cleanInventoriesData(data);
    if (fileKey === "minifigs") cleanedData = window.cleanMinifigsData(data);
    if (fileKey === "inventory_minifigs") cleanedData = window.cleanInventoryMinifigsData(data);

    // ‚úÖ CORRECTION : Sauvegarder cleanedData
    await db.saveData(fileKey, cleanedData, (current, total) => {
      const percentage = 60 + (current / total) * 40;
      progressFill.style.width = `${percentage}%`;
    });

    // Sauvegarder la date du fichier
    await db.setFileDate(fileKey, file.lastModified);

    progressFill.style.width = '100%';
    setTimeout(() => {
      fileDiv.className = 'file-item loaded';
      fileDiv.querySelector('.file-status-text').textContent = '‚úÖ Charg√©';
      fileDiv.querySelector('.file-status-text').className = 'file-status-text loaded';
      progressBar.style.display = 'none';
    }, 500);

    showSuccessMessage(`${file.name} trait√© avec succ√®s (${cleanedData.length.toLocaleString()} enregistrements)`);

  } catch (error) {
    console.error('Erreur traitement fichier:', error);
    fileDiv.className = 'file-item missing';
    fileDiv.querySelector('.file-status-text').textContent = '‚ùå Erreur';
    fileDiv.querySelector('.file-status-text').className = 'file-status-text missing';
    progressBar.style.display = 'none';
    showErrorMessage(`Erreur avec ${file.name}: ${error.message}`);
  }
}

    // Supprimer un fichier
    async function removeFile(fileKey) {
      if (confirm(`√ätes-vous s√ªr de vouloir supprimer les donn√©es ${REQUIRED_FILES[fileKey].name} ?`)) {
        const transaction = db.db.transaction([fileKey, 'metadata'], 'readwrite');
        await transaction.objectStore(fileKey).clear();
        await transaction.objectStore('metadata').delete(`${fileKey}_last_update`);
        await transaction.objectStore('metadata').delete(`${fileKey}_file_date`); // Nouveau
        await transaction.objectStore('metadata').delete(`${fileKey}_count`);
        
        await updateFileStatus();
        showInfoMessage(`Donn√©es ${REQUIRED_FILES[fileKey].name} supprim√©es.`);
      }
    }

// V√©rifier les mises √† jour disponibles sur Rebrickable
async function checkForUpdates() {
  showInfoMessage('V√©rification des mises √† jour en cours...');
  
  try {
    // R√©cup√©rer les dates des fichiers en ligne
    const onlineDates = await getOnlineFileDates();
    let statusMessage = '√âtat des fichiers :<br>';
    let hasUpdates = false;
    
    for (const fileKey of Object.keys(REQUIRED_FILES)) {
      const file = REQUIRED_FILES[fileKey];
      const localDate = await db.getFileDate(fileKey);
      const onlineDate = onlineDates[fileKey];
      const count = await db.getTableCount(fileKey);
      
      const fileDiv = document.getElementById(`file-${fileKey}`);
      
      if (onlineDate && localDate) {
        const localDateObj = new Date(localDate);
        const onlineDateObj = new Date(onlineDate);
        const isOutdated = onlineDateObj > localDateObj;
        
        if (isOutdated) {
          hasUpdates = true;
          fileDiv.classList.add('update-available');
          
          // Ajouter le bouton de mise √† jour
          const updateButton = document.createElement('button');
          updateButton.className = 'download-link update-button';
          updateButton.innerHTML = 'üîÑ Mettre √† jour';
          updateButton.onclick = () => downloadAndUpdateFile(fileKey);
          fileDiv.appendChild(updateButton);
        } else {
          fileDiv.classList.remove('update-available');
        }
        
        statusMessage += `‚Ä¢ ${file.name}: ${isOutdated ? '‚ö†Ô∏è Mise √† jour disponible' : '‚úÖ √Ä jour'} (local: ${localDateObj.toLocaleDateString()}, en ligne: ${onlineDateObj.toLocaleDateString()})<br>`;
      } else if (localDate) {
        statusMessage += `‚Ä¢ ${file.name}: ‚úÖ Donn√©es locales pr√©sentes (${new Date(localDate).toLocaleDateString()})<br>`;
      } else {
        statusMessage += `‚Ä¢ ${file.name}: ‚ùå Donn√©es manquantes<br>`;
      }
    }
    
    if (hasUpdates) {
      statusMessage += '<br>üîÑ Des mises √† jour sont disponibles. Cliquez sur "Mettre √† jour" pour chaque fichier.';
    } else {
      statusMessage += '<br>‚úÖ Tous les fichiers sont √† jour.';
    }
    
    showInfoMessage(statusMessage);
  } catch (error) {
    console.error('Erreur lors de la v√©rification des mises √† jour:', error);
    showErrorMessage('Impossible de v√©rifier les mises √† jour: ' + error.message);
  }
}

// T√©l√©charger et mettre √† jour un fichier
async function downloadAndUpdateFile(fileKey) {
  const file = REQUIRED_FILES[fileKey];
  showInfoMessage(`T√©l√©chargement de ${file.name} en cours...`);
  
  try {
    const response = await fetch(file.url);
    if (!response.ok) throw new Error('Erreur de t√©l√©chargement: ' + response.status);
    
    // Dans un environnement r√©el, il faudrait d√©compresser le fichier .gz
    // Pour cette d√©mo, nous allons simplement simuler le traitement
    showInfoMessage(`Le fichier ${file.name} a √©t√© t√©l√©charg√©. Veuillez le d√©compresser et l'importer manuellement.`);
    
  } catch (error) {
    console.error('Erreur lors du t√©l√©chargement:', error);
    showErrorMessage('Erreur de t√©l√©chargement: ' + error.message);
  }
}

// Obtenir les dates des fichiers en ligne (simulation)
async function getOnlineFileDates() {
  // En r√©alit√©, il faudrait faire une requ√™te HEAD pour obtenir les derni√®res modifications
  // Pour cette d√©mo, nous allons simuler des dates al√©atoires
  return new Promise((resolve) => {
    setTimeout(() => {
      const dates = {};
      const now = Date.now();
      const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
      
      for (const fileKey of Object.keys(REQUIRED_FILES)) {
        // 30% de chance que le fichier en ligne soit plus r√©cent
        const isNewer = Math.random() < 0.3;
        const localDate = db.getFileDate(fileKey);
        
        if (localDate && isNewer) {
          dates[fileKey] = new Date(localDate).getTime() + (2 * 24 * 60 * 60 * 1000);
        } else {
          dates[fileKey] = sevenDaysAgo + Math.random() * (now - sevenDaysAgo);
        }
      }
      
      resolve(dates);
    }, 1000);
  });
}

    // Effacer toutes les donn√©es
    async function clearAllData() {
      if (confirm('√ätes-vous s√ªr de vouloir effacer toutes les donn√©es stock√©es ? Cette action est irr√©versible.')) {
        try {
          await resetDatabase();
          location.reload();
        } catch (error) {
          showErrorMessage(`Erreur lors de la suppression: ${error.message}`);
        }
      }
    }

    async function resetDatabase() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase("LegoPartsDB");
        req.onsuccess = () => {
          console.log("IndexedDB supprim√©e.");
          resolve();
        };
        req.onerror = (e) => {
          console.error("Erreur suppression IndexedDB", e);
          reject(e);
        };
        req.onblocked = () => {
          console.warn("Suppression IndexedDB bloqu√©e (page encore ouverte ailleurs)");
        };
      });
    }
        // Afficher un message d'erreur dans l'app
    function showErrorInApp(message) {
      document.getElementById('app').innerHTML = `
        <div class="error">
          <h3>Erreur</h3>
          <p>${message}</p>
          <button class="btn" onclick="backToFileManager()">Retour √† la gestion des fichiers</button>
        </div>
      `;
    }

// Utiliser les fonctions du fichier mutualis√©

    // Fonction modifi√©e pour rediriger vers app.html
    async function launchApp() {
      // V√©rifier que tous les fichiers sont charg√©s
      const allFilesLoaded = await checkAllFilesLoaded();
      if (allFilesLoaded) {
        navigateTo('menu.html');
      } else {
        showErrorMessage('Tous les fichiers doivent √™tre charg√©s avant de lancer l\'application.');
      }
    }

    async function checkAllFilesLoaded() {
      for (const fileKey of Object.keys(REQUIRED_FILES)) {
        const count = await db.getTableCount(fileKey);
        if (count === 0) return false;
      }
      return true;
    }
  </script>
  <!-- SERVICE WORKER -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('‚úÖ Service Worker enregistr√©', reg.scope))
      .catch(err => console.error('‚ùå Erreur Service Worker:', err));
  });
}
</script>
<script src="./install-prompt.js"></script>
</body>
</html>