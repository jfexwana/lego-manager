<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <!-- META TAGS PWA - √Ä ajouter juste apr√®s <meta charset="UTF-8"> -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LEGO Manager">
<meta name="theme-color" content="#d32f2f">

<!-- PWA MANIFEST -->
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="./icon-192.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gestion des Sets LEGO</title>
  <link rel="stylesheet" href="./styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="./unified-data-manager.js"></script> 
  <script src="./debug.js"></script>
 <script>
// D√©tection automatique du chemin de base
const BASE_PATH = window.location.pathname.includes('/lego-manager/') 
  ? '/lego-manager' 
  : '';

function navigateTo(page) {
  window.location.href = `${BASE_PATH}/${page}`;
}
</script>
</head>
<body>
  <div class="container">
    <header class="d-flex justify-content-between align-items-center py-3 mb-4 border-bottom">
      <h1>Gestion des Sets LEGO üß±</h1>
      <div>
          <button id="back-to-sets-btn" class="btn btn-secondary me-2 d-none" onclick="showHomeView()">‚Üê Retour aux sets</button>
          <button id="back-to-menu-btn" class="btn btn-secondary me-2" onclick="goToMenu()">Retour au menu</button>
          <button id="toggle-darkmode" class="btn btn-outline-secondary">
            <i class="bi bi-moon-fill"></i>
        </button>
      </div>
    </header>

    <!-- Section de recherche et ajout de set -->
    <div class="card mb-4">
      <div class="card-body position-relative">
        <h5 class="card-title">Ajouter un set</h5>
        <div class="input-group mb-3">
          <input type="text" id="set-number-input" class="form-control" placeholder="Num√©ro ou nom de set (ex: 10280 ou Flower Bouquet)">
          <button id="add-set-btn" class="btn btn-success">Ajouter</button>
        </div>
        <div id="suggestions-container" class="suggestions-container"></div>
        <div class="mt-2">
          <label for="import-file" class="btn btn-sm btn-outline-secondary mb-0">
            <i class="bi bi-upload"></i> Importer des sets
          </label>
          <input type="file" id="import-file" accept=".json" class="d-none">
          
          <div class="dropdown d-inline-block ms-2">
            <button class="btn btn-sm btn-info dropdown-toggle" data-bs-toggle="dropdown">
              <i class="bi bi-download"></i> Exporter
            </button>
            <ul class="dropdown-menu">
              <li><a class="dropdown-item" href="#" data-format="json">JSON</a></li>
              <li><a class="dropdown-item" href="#" data-format="csv">CSV (Bricklink)</a></li>
              <li><a class="dropdown-item" href="#" data-format="xml">XML</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Liste des sets -->
    <div id="sets-container">
      <h3 class="mb-3">Mes Sets</h3>
      <div id="sets-grid" class="row g-3"></div>
      
      <div id="empty-collection-message" class="text-center py-5 d-none">
        <i class="bi bi-box display-1 text-muted"></i>
        <h3 class="mt-3 text-muted">Aucun set enregistr√©</h3>
        <p class="text-muted">Commencez par ajouter un set LEGO ci-dessus</p>
      </div>
    </div>

    <!-- Vue d√©taill√©e d'un set -->
    <div id="set-detail-view" class="d-none">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <button id="back-btn" class="btn btn-outline-secondary">‚Üê Retour √† la liste</button>
        <div class="form-check form-switch">
          <input type="checkbox" id="hide-completed" class="form-check-input">
          <label class="form-check-label" for="hide-completed">Masquer les pi√®ces compl√©t√©es</label>
        </div>
      </div>
      
      <div id="set-header" class="text-center mb-4"></div>
      <div id="parts-list" class="list-group"></div>
    </div>

    <!-- Vue des pi√®ces manquantes -->
    <div id="missing-view" class="d-none">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <button id="back-home-btn" class="btn btn-outline-secondary">‚Üê Retour √† la liste</button>
        <h2>Pi√®ces manquantes</h2>
      </div>
      <div id="missing-parts-list" class="list-group"></div>
    </div>

    <!-- Barre de sauvegarde -->
    <div class="fixed-bottom-bar">
      <div class="d-flex gap-2 justify-content-between align-items-center p-3">
        <div>
          <button id="view-missing-btn" class="btn btn-warning me-2">üì¶ Voir pi√®ces manquantes</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast container -->
  <div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 1080;"></div>

  <script src="./lego-db.js"></script>
  <script type="module">

  // Cache d'images global
    const setImageCache = new Map();
    const partImageCache = new Map();

  // Cache pour √©viter les rechargements inutiles
    const loadedParts = new Set();

  // ================================
  // VARIABLES GLOBALES
  // ================================
    let setManager = null;
    let legoDb = null;
    let currentView = 'home';
    let currentSetNumber = null;
    let isDarkMode = localStorage.getItem('darkMode') === 'true';
    let unifiedDataManager = null;

    // ================================
    // SET MANAGER
    // ================================
    class SetManager {
      constructor(apiKey, unifiedDataManager) {
        this.apiKey = apiKey;
        this.unifiedManager = unifiedDataManager;
        this.sets = [];
        this.isReady = false;
        // ‚úÖ NOUVEAUX CACHES
        this.partsMapCache = null;
        this.colorsMapCache = null;
  }
  async loadCacheMaps() {
  if (this.partsMapCache && this.colorsMapCache) return;
  
  const [partsData, colorsData] = await Promise.all([
    legoDb.getData('parts'),
    legoDb.getData('colors')
  ]);
  
  this.partsMapCache = new Map(partsData.map(p => [p.part_num, p]));
  this.colorsMapCache = new Map(colorsData.map(c => [c.id, c]));
  
  debug('‚úÖ Cache Maps charg√©s');
}
  // Nouvelle m√©thode pour v√©rifier si le manager est pr√™t
  async waitForReady() {
    if (this.isReady) return true;
    
    // Attendre que legoDb soit pr√™te si elle existe
    if (legoDb) {
      try {
        await legoDb.getData('parts');
        this.isReady = true;
        return true;
      } catch (error) {
        console.warn('IndexedDB non accessible:', error);
        // Continuer sans IndexedDB
      }
    }
    
    this.isReady = true;
    return true;
  }

  // Modifier fetchSetData pour attendre d'√™tre pr√™t
  async fetchSetData(setNumber) {
    // AJOUT : Attendre d'√™tre pr√™t
    await this.waitForReady();
    
    // V√©rifier si le set existe d√©j√† 
    if (this.unifiedManager.currentData.sets.some(s => s.number === setNumber)) {
      throw new Error('Ce set est d√©j√† dans votre collection');
    }

    try {
      // Essayer d'abord avec les donn√©es locales IndexedDB SI disponible
      if (legoDb) {
        let setFromLocal = await this.getSetFromIndexedDB(setNumber);
        if (setFromLocal) {
          debug('Set trouv√© dans IndexedDB');
          setFromLocal = await this.completePartsInfo(setFromLocal);
          this.sets.push(setFromLocal);
          this.saveToUnified();
          return setFromLocal;
        }
      }

      // Sinon, utiliser l'API Rebrickable
      debug('R√©cup√©ration depuis l\'API Rebrickable...');
      const setFromAPI = await this.fetchSetFromAPI(setNumber);
      return setFromAPI;
      
    } catch (error) {
      console.error('Erreur fetchSetData:', error);
      throw new Error('Erreur lors de la r√©cup√©ration des donn√©es du set: ' + error.message);
    }
  }


  // Charger les sets depuis le gestionnaire unifi√©
loadFromUnified() {
  this.sets = this.unifiedManager.currentData.sets.map(unifiedSet => {
    return {
      number: unifiedSet.number,
      name: unifiedSet.name,
      imageUrl: '',
      numParts: unifiedSet.parts.reduce((sum, p) => sum + p.quantity, 0),
      minifigsCount: 0,
      parts: unifiedSet.parts.map(p => {
        // ‚úÖ CORRECTION : D√©tecter is_spare correctement
        const isSpare = p.is_spare === true || 
                       p.is_spare === 1 || 
                       p.is_spare === 't' ||
                       p.is_spare === 'true';
        
        return {
          id: `${p.part_num}_${p.color_id}_${isSpare}`,
          partNum: p.part_num,
          name: '',
          color: '',
          colorId: p.color_id,
          quantity: p.quantity,
          quantityOwned: p.quantity_owned || 0,
          imageUrl: '',
          isSpare: isSpare,  // ‚úÖ Utiliser la valeur calcul√©e
          isMinifigPart: false
        };
      })
    };
  });
  
  // ‚úÖ AJOUT : Log de debug
  debug('üì• loadFromUnified() - Sets charg√©s:', this.sets.length);
  this.sets.forEach(set => {
    const spares = set.parts.filter(p => p.isSpare);
    debug(`  Set ${set.number}: ${set.parts.length} pi√®ces (${spares.length} spares)`);
  });
}

  // Ajouter cette m√©thode pour compl√©ter les informations des pi√®ces depuis IndexedDB
async completePartsInfo(set) {
  if (!legoDb) return set;
  
  try {
    // ‚úÖ Utiliser le cache
    await this.loadCacheMaps();
    
    set.parts = set.parts.map(part => {
      const partInfo = this.partsMapCache.get(part.partNum);
      const colorInfo = this.colorsMapCache.get(part.colorId);
      
      return {
        ...part,
        name: partInfo ? partInfo.name : part.name || 'Pi√®ce inconnue',
        color: colorInfo ? colorInfo.name : part.color || 'Couleur inconnue',
        imageUrl: partInfo ? partInfo.part_img_url : part.imageUrl || '',
        isSpare: part.isSpare || false
      };
    });
    
    return set;
  } catch (error) {
    console.error('Erreur completePartsInfo:', error);
    return set;
  }
}

async fetchMinifigsForSet(setNumber) {
  debugGroup('üîç fetchMinifigsForSet');
  debug('üì¶ Set number:', setNumber);
  
  try {
    if (!legoDb) {
      console.error('‚ùå legoDb non disponible, tentative API...');
      debugGroupEnd();
      
      // Fallback direct vers l'API
      try {
        const response = await fetch(
          `https://rebrickable.com/api/v3/lego/sets/${setNumber}/minifigs/?page_size=100`,
          { headers: { Authorization: `key ${this.apiKey}` } }
        );
        
        if (response.ok) {
          const data = await response.json();
          debug(`‚úÖ API: ${data.results.length} minifig(s) trouv√©e(s)`);
          
          const minifigs = await Promise.all(
            data.results.map(async (m, index) => {
              ///await this.delay(index * 200);
              const parts = await this.fetchMinifigPartsFromAPI(m.set_num);
              
              return {
                fig_num: m.set_num,
                name: m.set_name,
                quantity: m.quantity,
                img_url: m.set_img_url,
                parts: parts,
                completed: false
              };
            })
          );
          
          debugGroupEnd();
          return minifigs;
        }
      } catch (apiError) {
        console.error('‚ùå Erreur API minifigs:', apiError);
      }
      
      return [];
    }
    
    // ‚úÖ Utiliser la nouvelle m√©thode de LegoDatabase
    const minifigs = await legoDb.getMinifigsInSet(setNumber);
    debug(`üìä IndexedDB: ${minifigs.length} minifig(s) trouv√©e(s)`);
    
    if (minifigs.length === 0) {
      debug('‚ö†Ô∏è Aucune minifig dans IndexedDB, tentative API...');
      debugGroupEnd();
      
      // Fallback vers l'API si aucune minifig dans IndexedDB
      try {
        const response = await fetch(
          `https://rebrickable.com/api/v3/lego/sets/${setNumber}/minifigs/?page_size=100`,
          { headers: { Authorization: `key ${this.apiKey}` } }
        );
        
        if (response.ok) {
          const data = await response.json();
          const minifigsFromAPI = await Promise.all(
            data.results.map(async (m, index) => {
              //await this.delay(index * 200);
              const parts = await this.fetchMinifigPartsFromAPI(m.set_num);
              
              return {
                fig_num: m.set_num,
                name: m.set_name,
                quantity: m.quantity,
                img_url: m.set_img_url,
                parts: parts,
                completed: false
              };
            })
          );
          
          return minifigsFromAPI;
        }
      } catch (apiError) {
        console.error('‚ùå Erreur API:', apiError);
      }
      
      return [];
    }
    
    // R√©cup√©rer les pi√®ces pour chaque minifig depuis IndexedDB
    const minifigsWithParts = await Promise.all(
      minifigs.map(async (minifig) => {
        const parts = await legoDb.getMinifigParts(minifig.fig_num);
        return {
          ...minifig,
          parts: parts,
          completed: false
        };
      })
    );
    
    debug(`‚úÖ ${minifigsWithParts.length} minifig(s) compl√®tes retourn√©es`);
    debugGroupEnd();
    
    return minifigsWithParts;
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration minifigs:', error);
    debugGroupEnd();
    return [];
  }
}

// CORRECTION 2 : Nouvelle fonction pour r√©cup√©rer les pi√®ces via API
async fetchMinifigPartsFromAPI(figNum) {
  try {
    const response = await fetch(
      `https://rebrickable.com/api/v3/lego/minifigs/${figNum}/parts/?page_size=100`,
      { headers: { Authorization: `key ${this.apiKey}` } }
    );
    
    if (!response.ok) {
      console.warn(`API minifig parts √©chou√©e pour ${figNum}`);
      return [];
    }
    
    const data = await response.json();
    
    return data.results.map(p => ({
      part_num: p.part.part_num,
      name: p.part.name,
      color_id: p.color.id,
      color_name: p.color.name,
      quantity: p.quantity || 1,
      img_url: p.part.part_img_url
    }));
  } catch (error) {
    console.error(`Erreur API minifig parts ${figNum}:`, error);
    return [];
  }
}

async fetchMinifigParts(figNum) {
  debugGroup(`üîç fetchMinifigParts pour ${figNum}`);
  
  try {
    // 1. Trouver l'inventory de la minifig
    const inventories = await legoDb.getData('inventories');
    const minifigInventory = inventories.find(inv => inv.set_num === figNum);
    
    if (!minifigInventory) {
      console.warn(`‚ö†Ô∏è Pas d'inventory trouv√© pour la minifig ${figNum} dans IndexedDB`);
      debug('üåê Tentative via API...');
      debugGroupEnd();
      
      // Fallback API
      return await this.fetchMinifigPartsFromAPI(figNum);
    }
    
    debug(`‚úÖ Inventory minifig trouv√©: ID=${minifigInventory.id}`);
    
    // 2. R√©cup√©rer les pi√®ces de cet inventory
    const invParts = await legoDb.getDataByIndex('inventory_parts', 'inventory_id', minifigInventory.id);
    debug(`üìä ${invParts.length} pi√®ces trouv√©es`);
    
    if (invParts.length === 0) {
      console.warn('‚ö†Ô∏è Aucune pi√®ce dans IndexedDB, tentative API...');
      debugGroupEnd();
      return await this.fetchMinifigPartsFromAPI(figNum);
    }
    
    // 3. Enrichir avec les noms et couleurs
    const [partsData, colorsData] = await Promise.all([
      legoDb.getData('parts'),
      legoDb.getData('colors')
    ]);
    
    const partsMap = new Map(partsData.map(p => [p.part_num, p]));
    const colorsMap = new Map(colorsData.map(c => [c.id, c]));
    
    const parts = invParts.map(ip => {
      const part = partsMap.get(ip.part_num);
      const color = colorsMap.get(ip.color_id);
      
      return {
        part_num: ip.part_num,
        name: part ? part.name : 'Inconnu',
        color_id: ip.color_id,
        color_name: color ? color.name : 'Inconnu',
        quantity: ip.quantity || 1,
        img_url: ip.img_url
      };
    });
    
    debug(`‚úÖ ${parts.length} pi√®ces retourn√©es avec d√©tails`);
    debugGroupEnd();
    
    return parts;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration pi√®ces minifig:', error);
    debugGroupEnd();
    
    // Dernier fallback
    return await this.fetchMinifigPartsFromAPI(figNum);
  }
}


  // Mettre √† jour la quantit√© poss√©d√©e d'une pi√®ce
  updatePartQuantity(setNumber, partId, delta) {
    const set = this.sets.find(s => s.number === setNumber);
    if (!set) return;

    const part = set.parts.find(p => p.id === partId);
    if (!part || part.isSpare) return;

    part.quantityOwned = Math.max(0, Math.min(part.quantity, part.quantityOwned + delta));
    
    // Sauvegarder dans le format unifi√©
    this.unifiedManager.updateSetPartQuantity(setNumber, part.partNum, part.colorId, part.quantityOwned);
    this.unifiedManager.saveUnifiedData();
  }

  getSet(setNumber) {
    return this.sets.find(s => s.number === setNumber);
  }

  removeSet(setNumber) {
  debug(`Suppression du set ${setNumber}`);
  debug('Sets avant suppression:', this.sets.map(s => s.number));
  
  this.sets = this.sets.filter(s => s.number !== setNumber);
  this.unifiedManager.removeSet(setNumber);
  this.unifiedManager.saveUnifiedData();
  
  debug('Sets apr√®s suppression:', this.sets.map(s => s.number));
  }

  // Sauvegarder dans le format unifi√©
  saveToUnified() {
    this.unifiedManager.currentData.sets = this.sets.map(set => ({
      number: set.number,
      name: set.name,
parts: set.parts.map(p => ({
  part_num: p.partNum,
  color_id: p.colorId,
  quantity: p.quantity,
  quantity_owned: p.quantityOwned || 0,
  is_spare: p.isSpare || false
        }))
    }));
    
      // ‚úÖ AJOUT : Log de debug
  debug('üíæ saveToUnified() - Sauvegarde...');
  this.unifiedManager.currentData.sets.forEach(set => {
    const spares = set.parts.filter(p => p.is_spare);
    debug(`  Set ${set.number}: ${set.parts.length} pi√®ces (${spares.length} spares sauvegard√©es)`);
  });

    return this.unifiedManager.saveUnifiedData();
  }

async getSetFromIndexedDB(setNumber) {
  debugGroup('üíæ getSetFromIndexedDB');
  debug('üì¶ Set number:', setNumber);
  
  try {
    if (!legoDb || !legoDb.db) {
      debug('IndexedDB non disponible');
      debugGroupEnd();
      return null;
    }
    
    if (legoDb.db.version === 0) {
      debug('Connexion IndexedDB ferm√©e');
      debugGroupEnd();
      return null;
    }
    
    const setInfo = await legoDb.getSetByNum(setNumber);
    
    // CORRECTION : Chercher l'inventory_id correct
    const inventories = await legoDb.getData('inventories');
    const inventory = inventories.find(inv => inv.set_num === setNumber);
    
    if (!inventory) {
      debug(`Aucun inventory trouv√© pour ${setNumber}`);
      debugGroupEnd();
      return null;
    }
    
    debug(`‚úÖ Inventory trouv√©: ID=${inventory.id}`);
    
    const allInventoryParts = await legoDb.getData('inventory_parts');
    
    // ‚úÖ CORRECTION : Comparer en tant que strings (comme dans debug-comparison)
    const inventoryParts = allInventoryParts.filter(ip => 
      String(ip.inventory_id) === String(inventory.id)
    );
    
    if (!inventoryParts || inventoryParts.length === 0) {
      debug(`Aucune pi√®ce trouv√©e pour l'inventory ${inventory.id}`);
      debugGroupEnd();
      return null;
    }

    const [partsData, colorsData] = await Promise.all([
      legoDb.getData('parts').catch(() => []),
      legoDb.getData('colors').catch(() => [])
    ]);
    
    const partsMap = new Map(partsData.map(p => [p.part_num, p]));
    const colorsMap = new Map(colorsData.map(c => [c.id, c]));

    const parts = inventoryParts.map(invPart => {
      const part = partsMap.get(invPart.part_num);
      const color = colorsMap.get(invPart.color_id);
      
      // ‚úÖ CORRECTION : D√©tection identique au debug-comparison
      const rawSpareValue = invPart.is_spare;
      const isSpare =
        rawSpareValue === true ||
        rawSpareValue === 1 ||
        (typeof rawSpareValue === "string" &&
        ["t", "true"].includes(rawSpareValue.toLowerCase()));
      
      return {
        id: `${invPart.part_num}_${invPart.color_id}_${isSpare}`,
        partNum: invPart.part_num,
        name: part ? part.name : 'Pi√®ce inconnue',
        color: color ? color.name : 'Couleur inconnue',
        colorId: invPart.color_id,
        quantity: invPart.quantity || 1,
        quantityOwned: 0,
        imageUrl: invPart.img_url || '',
        isSpare: isSpare,
        isMinifigPart: false
      };
    });

    debug(`Set ${setNumber} trouv√© dans IndexedDB avec ${parts.length} pi√®ces`);
    
    const normalCount = parts.filter(p => !p.isSpare).length;
    const spareCount = parts.filter(p => p.isSpare).length;
    debug(`  ‚Ü≥ Normales: ${normalCount}, Spare: ${spareCount}`);
    
    debugGroupEnd();
    
    return {
      number: setNumber,
      name: setInfo ? setInfo.name : `Set ${setNumber}`,
      imageUrl: setInfo ? setInfo.img_url : '',
      numParts: parts.filter(p => !p.isSpare).reduce((sum, p) => sum + p.quantity, 0),
      minifigsCount: 0,
      parts: parts
    };

  } catch (error) {
    console.error('Erreur getSetFromIndexedDB:', error);
    debugGroupEnd();
    return null;
  }
}

async fetchSetFromAPI(setNumber) {
  debugGroup('üåê fetchSetFromAPI');
  debug('üì¶ Set number:', setNumber);
  
  const [setRes, partsRes, minifigsRes] = await Promise.all([
    fetch(`https://rebrickable.com/api/v3/lego/sets/${setNumber}/`, {
      headers: { Authorization: `key ${this.apiKey}` }
    }),
    fetch(`https://rebrickable.com/api/v3/lego/sets/${setNumber}/parts/?page_size=1000`, {
      headers: { Authorization: `key ${this.apiKey}` }
    }),
    fetch(`https://rebrickable.com/api/v3/lego/sets/${setNumber}/minifigs/?page_size=1000`, {
      headers: { Authorization: `key ${this.apiKey}` }
    })
  ]);

      // ‚úÖ CORRECTION : Meilleure gestion des erreurs 404
  
      if (!setRes.ok) {
      if (setRes.status === 404) {
        throw new Error(`Set "${setNumber}" non trouv√© dans la base de donn√©es Rebrickable`);
      } else {
        throw new Error(`Erreur API: ${setRes.status} ${setRes.statusText}`);
      }
    }

  const setData = await setRes.json();
  const partsData = partsRes.ok ? await partsRes.json() : { results: [] };
  const minifigsData = minifigsRes.ok ? await minifigsRes.json() : { results: [] };
  
  debug(`üìä Set: ${setData.name}`);
  debug(`üìä Parts API: ${partsData.results.length}`);
  debug(`üìä Minifigs API: ${minifigsData.results.length}`);

  // R√©cup√©rer les pi√®ces de minifigures si n√©cessaire
  let minifigParts = [];
  if (minifigsData.results.length > 0) {
    debug('üîç R√©cup√©ration des pi√®ces de minifigs...');
    const minifigPartsPromises = minifigsData.results.map(async (minifig, index) => {
      //await this.delay(index * 200);
      try {
        const minifigPartsRes = await fetch(
          `https://rebrickable.com/api/v3/lego/minifigs/${minifig.set_num}/parts/?page_size=1000`,
          { headers: { Authorization: `key ${this.apiKey}` } }
        );
        if (minifigPartsRes.ok) {
          const minifigPartsData = await minifigPartsRes.json();
          debug(`  ‚Ü≥ ${minifig.set_num}: ${minifigPartsData.results.length} pi√®ces`);
          return minifigPartsData.results || [];
        }
        return [];
      } catch (error) {
        console.error(`Erreur r√©cup√©ration pi√®ces minifig ${minifig.set_num}:`, error);
        return [];
      }
    });

    const minifigPartsResults = await Promise.all(minifigPartsPromises);
    minifigParts = minifigPartsResults.flat();
    debug(`üìä Total pi√®ces de minifigs: ${minifigParts.length}`);
  }

  const allParts = [...partsData.results, ...minifigParts];
  
  // ‚úÖ CORRECTION : Compter les spare parts
const normalPartsCount = allParts
  .filter(p => !p.is_spare)
  .reduce((sum, p) => sum + (p.quantity || 1), 0);

const sparePartsCount = allParts
  .filter(p => p.is_spare)
  .reduce((sum, p) => sum + (p.quantity || 1), 0);
  
  debug(`üìä Parts normales: ${normalPartsCount}`);
  debug(`üìä Spare parts: ${sparePartsCount}`);

  const legoSet = {
    number: setData.set_num,
    name: setData.name,
    imageUrl: setData.set_img_url,
    numParts: normalPartsCount,
    minifigsCount: minifigsData.results.length,
    parts: allParts.map(p => ({
      id: `${p.part.part_num}_${p.color.id}_${p.is_spare}`,
      partNum: p.part.part_num,
      name: p.part.name,
      color: p.color.name,
      colorId: p.color.id,
      quantity: p.quantity,
      quantityOwned: 0,
      imageUrl: p.part.part_img_url,
      isSpare: p.is_spare, // ‚úÖ Important !
      isMinifigPart: minifigParts.some(mp => 
        mp.part.part_num === p.part.part_num && 
        mp.color.id === p.color.id
      )
    }))
  };

  debug('‚úÖ Set complet cr√©√©');
  debugGroupEnd();

  this.sets.push(legoSet);
  this.saveToUnified();
  return legoSet;
}

      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      getSet(setNumber) {
        return this.sets.find(s => s.number === setNumber);
      }

       getCompletionStats() {
        const totalSets = this.sets.length;
        const completedSets = this.sets.filter(set =>
          set.parts.filter(p => !p.isSpare).every(part => part.quantityOwned >= part.quantity)
        ).length;

        return {
          totalSets,
          completedSets,
          completionPercentage: totalSets > 0 ? (completedSets / totalSets) * 100 : 0
        };
      }

      getMissingPartsGroupedByPart() {
        const partsMap = new Map();

        this.sets.forEach(set => {
          set.parts
            .filter(p => !p.isSpare && p.quantityOwned < p.quantity)
            .forEach(p => {
              const key = `${p.partNum}_${p.colorId}`;
              if (!partsMap.has(key)) {
                partsMap.set(key, {
                  id: p.id,
                  partNum: p.partNum,
                  name: p.name,
                  color: p.color,
                  colorId: p.colorId,
                  imageUrl: p.imageUrl,
                  totalMissing: 0,
                  sets: []
                });
              }
              const partData = partsMap.get(key);
              const missing = p.quantity - p.quantityOwned;
              partData.totalMissing += missing;
              partData.sets.push({
                number: set.number,
                name: set.name,
                imageUrl: set.imageUrl,
                missing: missing
              });
            });
        });

        return Array.from(partsMap.values()).sort((a, b) => b.totalMissing - a.totalMissing);
      }

async checkInventoryForPart(partNum, colorId) {
  try {
    const inventoryData = localStorage.getItem("lego_personal_inventory");
    if (!inventoryData) return 0;
    
    const inventory = JSON.parse(inventoryData);
    const part = inventory.find(p => 
      p.part_num === partNum && p.color_id === parseInt(colorId)
    );
    
    return part ? part.quantity : 0;
  } catch (error) {
    console.error('Erreur v√©rification inventaire:', error);
    return 0;
  }
}
    }

    // ================================
    // STORAGE MANAGER
    // ================================


    // ================================
    // INITIALISATION
    // ================================
    document.addEventListener('DOMContentLoaded', async function() {
      if (isDarkMode) {
        document.body.classList.add('dark-mode');
        document.getElementById('toggle-darkmode').innerHTML = '<i class="bi bi-sun-fill"></i>';
      }
      
      await initApp();
      initEventListeners();
    });
    // Gestionnaire global pour les boutons de minifig
document.addEventListener('click', (e) => {
  const btn = e.target.closest('[data-action^="minifig-"]');
  if (!btn) return;
  
  const action = btn.dataset.action;
  const partNum = btn.dataset.partNum;
  const colorId = parseInt(btn.dataset.colorId);
  const minifigId = btn.dataset.minifigId;
  
  handleMinifigPartAction(action, partNum, colorId, minifigId);
});

// Ajoutez ce gestionnaire dans initEventListeners() ou apr√®s l'initialisation
document.addEventListener('click', (e) => {
  const btn = e.target.closest('[data-action="decrement"], [data-action="increment"]');
  if (!btn) return;
  
  // Exclure les boutons de minifigs
  if (btn.closest('.minifig-parts-list')) return;
  
  const action = btn.dataset.action;
  const setNumber = btn.dataset.setNumber;
  const partId = btn.dataset.partId;
  
  if (setNumber && partId) {
    const delta = action === 'increment' ? 1 : -1;
    setManager.updatePartQuantity(setNumber, partId, delta);
    
    // Forcer le re-rendu de l'affichage
    renderSetParts(setNumber);
    renderSetHeader(setNumber);
  }
});

// Gestionnaire pour les checkboxes de minifig
document.addEventListener('change', (e) => {
  if (!e.target.classList.contains('minifig-part-checkbox')) return;
  
  const checkbox = e.target;
  const minifigId = checkbox.dataset.minifigId;
  const partNum = checkbox.dataset.partNum;
  const colorId = parseInt(checkbox.dataset.colorId);
  
  handleMinifigPartCheckbox(checkbox.checked, partNum, colorId, minifigId);
});

async function initApp() {
  try {
    showToast('Initialisation de l\'application...', 'info');
    
    // V√©rifier la cl√© API
    const apiKey = localStorage.getItem('rebrickable_api_key');
    if (!apiKey) {
      showToast('Veuillez configurer votre cl√© API Rebrickable dans le menu principal.', 'warning');
      setTimeout(() => {
        navigateTo('menu.html');
      }, 3000);
      return;
    }

    // Initialiser IndexedDB
    try {
      legoDb = new LegoDatabase();
      await legoDb.init();
      await legoDb.verifyAndRepairStores();
      
      // CORRECTION : V√©rifier que les donn√©es sont accessibles
      try {
        await legoDb.getData('parts');
        debug('IndexedDB compl√®tement op√©rationnelle');
      } 
      catch (testError) {  // CORRIGER ICI : c'√©tait 'error' avant
        console.warn('IndexedDB non accessible, utilisation API uniquement:', testError);
        legoDb = null; // Forcer l'utilisation de l'API
      }
    } catch (error) {
      console.warn('IndexedDB non disponible, utilisation API uniquement:', error);
      legoDb = null; // AJOUTER cette ligne
    }

    // Initialiser le gestionnaire unifi√©
    unifiedDataManager = new UnifiedDataManager();
    await unifiedDataManager.loadUnifiedData();

    // Initialiser les managers
    setManager = new SetManager(apiKey, unifiedDataManager);
    
    // Charger les sets depuis le format unifi√©
    setManager.loadFromUnified(); // Cette m√©thode existe maintenant

        // NOUVEAU : Initialiser le gestionnaire de boutons s√©curis√©
    if (window.secureButtonManager) {
      window.secureButtonManager.initialize();
    }

    showHomeView();
    showToast('Application initialis√©e avec succ√®s', 'success');
    
  } catch (error) {
    console.error('Erreur lors de l\'initialisation:', error);
    showToast('Erreur lors de l\'initialisation: ' + error.message, 'error');
  }
}

    function initEventListeners() {
      // Navigation
      document.getElementById('back-btn').addEventListener('click', showHomeView);
      document.getElementById('back-home-btn').addEventListener('click', showHomeView);
      document.getElementById('view-missing-btn').addEventListener('click', showMissingView);
      
      // Mode sombre
      document.getElementById('toggle-darkmode').addEventListener('click', toggleDarkMode);
      
      // Ajout de set
      document.getElementById('add-set-btn').addEventListener('click', handleAddSet);
      document.getElementById('set-number-input').addEventListener('input', handleSearchInput);
      document.getElementById('set-number-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleAddSet();
      });
      
      // Filtres
      document.getElementById('hide-completed').addEventListener('change', () => {
        if (currentSetNumber) renderSetParts(currentSetNumber);
      });
      
      // Import/Export
      document.getElementById('import-file').addEventListener('change', handleFileImport);
      document.querySelectorAll('[data-format]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          handleExport(e.target.dataset.format);
        });
      });
    }
      
    // ================================
    // FONCTIONS D'AFFICHAGE
    // ================================
    function showHomeView() {
      currentView = 'home';
      currentSetNumber = null;
      
      document.getElementById('sets-container').classList.remove('d-none');
      document.getElementById('set-detail-view').classList.add('d-none');
      document.getElementById('missing-view').classList.add('d-none');

      // G√©rer les boutons du header
      document.getElementById('back-to-sets-btn').classList.add('d-none');
      document.getElementById('back-to-menu-btn').classList.remove('d-none');
      
      renderSetsGrid();
    }

    function showSetDetailView(setNumber) {
      currentView = 'detail';
      currentSetNumber = setNumber;
      
      document.getElementById('sets-container').classList.add('d-none');
      document.getElementById('set-detail-view').classList.remove('d-none');
      document.getElementById('missing-view').classList.add('d-none');

      // G√©rer les boutons du header
      document.getElementById('back-to-sets-btn').classList.remove('d-none');
      document.getElementById('back-to-menu-btn').classList.add('d-none');
      
      renderSetHeader(setNumber);
      renderSetParts(setNumber);
    }

    function showMissingView() {
      currentView = 'missing';
      currentSetNumber = null;
      
      document.getElementById('sets-container').classList.add('d-none');
      document.getElementById('set-detail-view').classList.add('d-none');
      document.getElementById('missing-view').classList.remove('d-none');

      // G√©rer les boutons du header
      document.getElementById('back-to-sets-btn').classList.remove('d-none');
      document.getElementById('back-to-menu-btn').classList.add('d-none');
      
      Promise.all(setManager.sets.map(s => setManager.completePartsInfo(s))).then(() => {
  renderMissingParts();
      });
    }

    function renderSetsGrid() {
      const container = document.getElementById('sets-grid');
      const emptyMessage = document.getElementById('empty-collection-message');
      const apiKey = localStorage.getItem('rebrickable_api_key');

      
      if (!setManager || setManager.sets.length === 0) {
        container.innerHTML = '';
        emptyMessage.classList.remove('d-none');
        return;
      }
      
      emptyMessage.classList.add('d-none');
      
      const stats = setManager.getCompletionStats();
      
      container.innerHTML = `
        <div class="col-12 mb-4">
          <div class="alert alert-info">
            <i class="bi bi-info-circle"></i>
            <strong>${stats.completedSets}/${stats.totalSets}</strong> sets compl√©t√©s 
            (${stats.completionPercentage.toFixed(1)}%)
          </div>
        </div>
      `;
      
setManager.sets.forEach(set => {
  const normalParts = set.parts.filter(p => !p.isSpare);
  const completedParts = normalParts.filter(p => p.quantityOwned >= p.quantity);
  const isCompleted = completedParts.length === normalParts.length;
  const progress = normalParts.length > 0 ? (completedParts.length / normalParts.length) * 100 : 0;
  
  // ‚úÖ CORRECTION : Calculer le nombre total de pi√®ces normales
  const totalNormalPieces = normalParts.reduce((sum, p) => sum + p.quantity, 0);
  
  const card = document.createElement('div');
  card.className = 'col-md-6 col-lg-4';
  card.innerHTML = `
    <div class="card h-100 set-card ${isCompleted ? 'completed' : ''}" style="cursor: pointer;">
      <div class="set-image-container" style="height: 200px; overflow: hidden;">
        <img class="card-img-top" alt="${set.name}" 
             style="width: 100%; height: 200px; object-fit: contain; opacity: 0; transition: opacity 0.3s;">
      </div>
      <div class="card-body d-flex flex-column">
        <h5 class="card-title">${set.name}</h5>
        <p class="card-text text-muted">#${set.number} ‚Ä¢ ${totalNormalPieces} pi√®ces</p>
        <div class="progress mb-3">
          <div class="progress-bar ${isCompleted ? 'bg-success' : 'bg-primary'}" 
               style="width: ${progress}%"></div>
        </div>
        <div class="mt-auto">
          <button class="btn btn-outline-danger btn-sm" data-action="remove" onclick="event.stopPropagation();">
            <i class="bi bi-trash"></i> Supprimer
          </button>
        </div>
      </div>
    </div>
`;

    // Charger l'image apr√®s cr√©ation du DOM
  const img = card.querySelector('img');
  loadSetImageWithAPI(img, set.number, set.imageUrl, apiKey, false);

       card.addEventListener('click', (e) => {
         if (!e.target.closest('[data-action="remove"]')) {
           showSetDetailView(set.number);
         }
       });
       
       card.querySelector('[data-action="remove"]').addEventListener('click', (e) => {
         e.stopPropagation();
         if (confirm(`Supprimer le set "${set.name}" ?`)) {
           setManager.removeSet(set.number);
           renderSetsGrid();
           showToast('Set supprim√©', 'info');
         }
       });
       
       container.appendChild(card);
     });
   }

   function renderSetHeader(setNumber) {
     const set = setManager.getSet(setNumber);
     if (!set) return;
     
     const normalParts = set.parts.filter(p => !p.isSpare);
     const totalOwned = normalParts.reduce((sum, part) => sum + part.quantityOwned, 0);
     const totalNeeded = normalParts.reduce((sum, part) => sum + part.quantity, 0);
     const progress = totalNeeded > 0 ? (totalOwned / totalNeeded) * 100 : 0;
     
document.getElementById('set-header').innerHTML = `
  <div class="set-header-image" style="text-align: center; margin-bottom: 20px;">
    <img alt="${set.name}" class="mb-3" 
         style="max-height: 200px; max-width: 100%; opacity: 0; transition: opacity 0.3s;">
  </div>
  <h2>${set.name}</h2>
         <p>${totalOwned}/${totalNeeded} pi√®ces poss√©d√©es (${progress.toFixed(1)}%)</p>
     `;

     // Charger l'image apr√®s cr√©ation du DOM
     const headerImg = document.querySelector('#set-header img');
const apiKey = localStorage.getItem('rebrickable_api_key');
loadSetImageWithAPI(headerImg, set.number, set.imageUrl, apiKey, true);

   }

// Fonction optimis√©e pour les images de sets avec cache et priorit√© au lien direct
async function loadSetImageWithAPI(imgElement, setNumber, originalUrl, apiKey, isSetHeader = false) {
  const cacheKey = `set_${setNumber}`;
  
  // V√©rifier le cache d'abord
  if (setImageCache.has(cacheKey)) {
    const cachedUrl = setImageCache.get(cacheKey);
    imgElement.src = cachedUrl;
    imgElement.style.opacity = '1';
    debug(`‚úì Image charg√©e depuis le cache: ${cachedUrl}`);
    return;
  }

  // NOUVEAU : Essayer d'abord avec sets.csv
  try {
    const setInfo = await legoDb.getSetByNum(setNumber);
    if (setInfo && setInfo.img_url) {
      const imageExists = await testImageUrl(setInfo.img_url);
      if (imageExists) {
        imgElement.src = setInfo.img_url;
        imgElement.style.opacity = '1';
        setImageCache.set(cacheKey, setInfo.img_url);
        debug(`‚úì Image charg√©e depuis sets.csv: ${setInfo.img_url}`);
        return;
      }
    }
  } catch (error) {
    debug('Erreur acc√®s sets.csv:', error);
  }  

  // Construire la liste des URLs √† tester
  const fallbackUrls = [
    `https://cdn.rebrickable.com/media/sets/${setNumber}-1.jpg`, // Format standard en priorit√©
    originalUrl, // URL de l'API si disponible
    `https://cdn.rebrickable.com/media/sets/${setNumber}.jpg`, // Format sans -1
    `https://cdn.rebrickable.com/media/sets/${setNumber}/set_img.jpg`, // Format alternatif
  ].filter(url => url && url.trim() && !url.includes('placeholder'));

  debug(`Tests d'images pour le set ${setNumber}:`, fallbackUrls);

  let imageLoaded = false;

  for (let i = 0; i < fallbackUrls.length && !imageLoaded; i++) {
    const url = fallbackUrls[i];
    debug(`Test ${i + 1}/${fallbackUrls.length}: ${url}`);
    
    try {
      const imageExists = await testImageUrl(url);
      if (imageExists) {
        imgElement.src = url;
        imgElement.style.opacity = '1';
        debug(`‚úì Image charg√©e: ${url}`);
        
        // Mettre en cache
        setImageCache.set(cacheKey, url);
        imageLoaded = true;
        break;
      } else {
        debug(`‚úó Image inaccessible: ${url}`);
      }
    } catch (error) {
      debug(`‚úó Erreur pour ${url}:`, error);
    }
  }

  // Si aucune image trouv√©e, essayer l'API
  if (!imageLoaded && (!originalUrl || originalUrl.includes('placeholder'))) {
    try {
      debug(`Tentative API pour le set ${setNumber}...`);
      const response = await fetch(`https://rebrickable.com/api/v3/lego/sets/${setNumber}/`, {
        headers: { 
          'Authorization': `key ${apiKey}`,
          'Accept': 'application/json'
        }
      });
      
      if (response.ok) {
        const setData = await response.json();
        const apiImageUrl = setData.set_img_url;
        debug(`URL d'image r√©cup√©r√©e via API: ${apiImageUrl}`);
        
        if (apiImageUrl) {
          const imageExists = await testImageUrl(apiImageUrl);
          if (imageExists) {
            imgElement.src = apiImageUrl;
            imgElement.style.opacity = '1';
            setImageCache.set(cacheKey, apiImageUrl);
            imageLoaded = true;
            debug(`‚úì Image charg√©e via API: ${apiImageUrl}`);
          }
        }
      }
    } catch (error) {
      debug(`Erreur API pour ${setNumber}:`, error);
    }
  }

  if (!imageLoaded) {
    console.error(`Aucune image trouv√©e pour le set ${setNumber}`);
    showImageDebugInfo(imgElement, setNumber, fallbackUrls, isSetHeader);
  }
}

// Fonction pour tester si une image existe (inchang√©e)
function testImageUrl(url) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = url;
    setTimeout(() => resolve(false), 5000);
  });
}

// Fonction debug am√©lior√©e
function showImageDebugInfo(imgElement, setNumber, testedUrls, isSetHeader = false) {
  const height = isSetHeader ? '200px' : '150px';
  const container = imgElement.parentNode;
  
  container.innerHTML = `
    <div style="height: ${height}; background: #f8f9fa; border: 2px dashed #dee2e6; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 15px; text-align: center; border-radius: 8px;">
      <i class="bi bi-image" style="font-size: 2em; color: #6c757d; margin-bottom: 10px;"></i>
      <div style="font-size: 0.9em; font-weight: bold; color: #495057; margin-bottom: 5px;">
        Image non disponible
      </div>
      <div style="font-size: 0.8em; color: #6c757d; margin-bottom: 10px;">
        Set ${setNumber}
      </div>
      
      <details style="font-size: 0.75em; color: #6c757d; max-width: 100%; cursor: pointer;">
        <summary style="margin-bottom: 8px; cursor: pointer; padding: 4px 8px; background: #e9ecef; border-radius: 4px;">
          Voir les ${testedUrls.length} URLs test√©es
        </summary>
        <div style="text-align: left; background: #ffffff; border: 1px solid #dee2e6; border-radius: 4px; padding: 8px; margin-top: 5px; max-height: 120px; overflow-y: auto;">
          ${testedUrls.map((url, index) => `
            <div style="margin-bottom: 6px; padding: 4px; background: ${index === 0 ? '#fff3cd' : '#f8f9fa'}; border-radius: 2px; word-break: break-all; font-family: monospace; font-size: 0.7em;">
              <div style="display: flex; align-items: center; margin-bottom: 2px;">
                <span style="background: ${index === 0 ? '#856404' : '#495057'}; color: white; padding: 1px 4px; border-radius: 2px; margin-right: 6px; font-size: 0.8em;">
                  ${index === 0 ? 'API' : 'FB' + index}
                </span>
                <span style="color: #dc3545; font-weight: bold;">‚úó</span>
              </div>
              <a href="${url}" target="_blank" style="color: #007bff; text-decoration: none;" 
                 onmouseover="this.style.textDecoration='underline'" 
                 onmouseout="this.style.textDecoration='none'">${url}</a>
            </div>
          `).join('')}
        </div>
      </details>
      
      <div style="margin-top: 8px; font-size: 0.7em; color: #6c757d;">
        API: URL de l'API ‚Ä¢ FB: Fallback
      </div>
    </div>
  `;
}

async function handleMinifigPartAction(action, partNum, colorId, minifigId) {
  const currentQty = unifiedDataManager.getInventoryQuantity(partNum, colorId);
  
  // ‚úÖ CORRECTION : R√©cup√©rer la quantit√© n√©cessaire
  const qtyDisplay = document.getElementById(`minifig-qty-${minifigId}-${partNum}-${colorId}`);
  if (!qtyDisplay) return;
  
  const match = qtyDisplay.textContent.match(/\/(\d+)/);
  const needed = match ? parseInt(match[1]) : 1;
  
  // ‚úÖ CORRECTION : Emp√™cher de d√©passer la quantit√© n√©cessaire
  const delta = action === 'minifig-increment' ? 1 : -1;
  const newQty = Math.max(0, Math.min(needed, currentQty + delta));
  
  // R√©cup√©rer le nom de la couleur
  const colors = await legoDb.getData('colors');
  const color = colors.find(c => c.id === colorId);
  const colorName = color ? color.name : 'Couleur inconnue';
  
  const inventoryItem = unifiedDataManager.currentData.inventory.find(
    item => item.part_num === partNum && item.color_id === colorId
  );
  
  unifiedDataManager.updateInventory(
    partNum, 
    colorId, 
    colorName, 
    newQty, 
    inventoryItem ? inventoryItem.category : 'Minifig'
  );
  
  await unifiedDataManager.saveUnifiedData();
  
  // Mettre √† jour l'affichage
  qtyDisplay.textContent = `${newQty}/${needed}`;
  
  // ‚úÖ CORRECTION : Mettre √† jour l'√©tat des boutons
  const incrementBtn = document.querySelector(
    `[data-action="minifig-increment"][data-part-num="${partNum}"][data-color-id="${colorId}"][data-minifig-id="${minifigId}"]`
  );
  const decrementBtn = document.querySelector(
    `[data-action="minifig-decrement"][data-part-num="${partNum}"][data-color-id="${colorId}"][data-minifig-id="${minifigId}"]`
  );
  const checkbox = document.querySelector(
    `.minifig-part-checkbox[data-part-num="${partNum}"][data-color-id="${colorId}"][data-minifig-id="${minifigId}"]`
  );
  
  if (incrementBtn) incrementBtn.disabled = newQty >= needed;
  if (decrementBtn) decrementBtn.disabled = newQty <= 0;
  if (checkbox) checkbox.checked = newQty >= needed;

    // ‚úÖ AJOUT : Recalculer la compl√©tion de la minifig
  updateMinifigCompletion(minifigId);
}

// ‚úÖ NOUVELLE FONCTION √† ajouter
function updateMinifigCompletion(minifigId) {
  const minifigCard = document.querySelector(`[data-minifig-id="${minifigId}"]`)?.closest('.card');
  if (!minifigCard) return;
  
  const allParts = minifigCard.querySelectorAll('.minifig-part-checkbox');
  const completedParts = Array.from(allParts).filter(cb => cb.checked).length;
  const totalParts = allParts.length;
  
  const completion = totalParts > 0 ? Math.round((completedParts / totalParts) * 100) : 0;
  
  const progressBar = minifigCard.querySelector('.progress-bar');
  if (progressBar) {
    progressBar.style.width = `${completion}%`;
    progressBar.textContent = `${completion}%`;
  }
    // ‚úÖ AJOUT : Griser la minifig si 100%
  if (completion === 100) {
    minifigCard.classList.add('completed');
  } else {
    minifigCard.classList.remove('completed');
  }
  
  // ‚úÖ AJOUT : Griser chaque ligne de pi√®ce compl√©t√©e
  allParts.forEach(checkbox => {
    const row = checkbox.closest('.parts-table-row');
    if (row) {
      if (checkbox.checked) {
        row.classList.add('minifig-completed');
      } else {
        row.classList.remove('minifig-completed');
      }
    }
  });
}

async function handleMinifigPartCheckbox(isChecked, partNum, colorId, minifigId) {
  // R√©cup√©rer la quantit√© n√©cessaire depuis l'affichage
  const qtyDisplay = document.getElementById(`minifig-qty-${minifigId}-${partNum}-${colorId}`);
  if (!qtyDisplay) return;
  
  const match = qtyDisplay.textContent.match(/\/(\d+)/);
  const needed = match ? parseInt(match[1]) : 1;
  
  const newQty = isChecked ? needed : 0;
  
  // R√©cup√©rer le nom de la couleur
  const colors = await legoDb.getData('colors'); // ‚úÖ CORRECTION : legoDb au lieu de db
  const color = colors.find(c => c.id === colorId);
  const colorName = color ? color.name : 'Couleur inconnue';
  
  // Mettre √† jour l'inventaire
  const inventoryItem = unifiedDataManager.currentData.inventory.find(
    item => item.part_num === partNum && item.color_id === colorId
  );
  
  unifiedDataManager.updateInventory(
    partNum, 
    colorId, 
    colorName, 
    newQty, 
    inventoryItem ? inventoryItem.category : 'Minifig'
  );
  
  await unifiedDataManager.saveUnifiedData();
  
  // Recharger l'affichage
  if (currentSetNumber) {
    renderSetParts(currentSetNumber);
  }
}

// Rendu de la liste des pi√®ces d'un set avec cache optimis√©
async function renderSetParts(setNumber) {
  debugGroup('üìã renderSetParts appel√©');
  debug('üîç Set number:', setNumber);
  
  const set = setManager.getSet(setNumber);
  if (!set) {
    console.error('‚ùå Set non trouv√©');
    debugGroupEnd();
    return;
  }
  
  debug('üì¶ Set trouv√©:', set.name);
  debug('üìä Parts total:', set.parts.length);
  
  const container = document.getElementById('parts-list');
  const hideCompleted = document.getElementById('hide-completed').checked; // ‚úÖ R√©cup√©rer l'√©tat du filtre
  
  // Compl√©ter les informations des pi√®ces depuis IndexedDB si n√©cessaire
  await setManager.completePartsInfo(set);
  
  debug('üîç R√©cup√©ration des minifigs...');
  const minifigs = await setManager.fetchMinifigsForSet(setNumber);
  debug(`üìä ${minifigs.length} minifig(s) trouv√©e(s)`);
  
  // Cr√©er un Set des pi√®ces de minifigs pour les exclure
  const minifigPartKeys = new Set();
  minifigs.forEach(minifig => {
    if (minifig.parts) {
      minifig.parts.forEach(part => {
        minifigPartKeys.add(`${part.part_num}_${part.color_id}`);
      });
    }
  });
  
  // S√©parer les pi√®ces en excluant celles des minifigs
  const normalParts = [];
  const spareParts = [];
  const minifigParts = [];

  set.parts.forEach(p => {
    const partKey = `${p.partNum}_${p.colorId}`;
    
    if (minifigPartKeys.has(partKey)) {
      minifigParts.push(p);
    } else if (p.isSpare) {
      spareParts.push(p);
    } else {
      normalParts.push(p);
    }
  });

  debug('üìä Statistiques parties CORRIG√âES:');
  debug('  ‚Ü≥ Normal parts:', normalParts.length);
  debug('  ‚Ü≥ Spare parts:', spareParts.length);
  debug('  ‚Ü≥ Minifig parts:', minifigParts.length);

  // Cr√©er l'en-t√™te du tableau
  const header = document.createElement('div');
  header.className = 'parts-table-header';
  header.innerHTML = `
    <div class="part-col-image">Image</div>
    <div class="part-col-name">Nom</div>
    <div class="part-col-number">Num√©ro</div>
    <div class="part-col-color">Couleur</div>
    <div class="part-col-controls">Actions</div>
    <div class="part-col-counts">Quantit√©</div>
    <div class="part-col-all">Toutes</div>
  `;
  container.innerHTML = '';
  container.appendChild(header);
  
  // ========================================
  // 1. SECTION MINIFIGS (en premier)
  // ========================================
  if (minifigs.length > 0) {
    debug('üé® Affichage des minifigs:');
    minifigs.forEach((m, i) => {
      debug(`  ${i + 1}. ${m.name} (${m.fig_num}) - ${m.parts?.length || 0} pi√®ces`);
    });
    
    const minifigsSection = document.createElement('div');
    minifigsSection.className = 'minifigs-section mb-4';
    minifigsSection.innerHTML = `
      <h5 style="margin: 30px 0 20px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
        <i class="bi bi-person-standing" style="font-size: 1.5em;"></i>
        <span>Minifigures (${minifigs.length})</span>
      </h5>
    `;
    
    for (const minifig of minifigs) {
      const minifigParts = minifig.parts || [];
      const completedMinifigParts = minifigParts.filter(p => {
        const inventoryQty = unifiedDataManager.getInventoryQuantity(p.part_num, p.color_id);
        return inventoryQty >= (p.quantity || 1);
      });
      const minifigCompletion = minifigParts.length > 0 
        ? (completedMinifigParts.length / minifigParts.length * 100).toFixed(0)
        : 0;
      
      const isMinifigComplete = minifigCompletion === '100';
      
      // ‚úÖ AJOUT : Masquer la minifig si elle est compl√®te ET le filtre activ√©
      if (hideCompleted && isMinifigComplete) {
        continue; // Passer √† la minifig suivante
      }
      
      const minifigCard = document.createElement('div');
      minifigCard.className = 'card mb-4';
      minifigCard.style.cssText = 'border: 2px solid #667eea; box-shadow: 0 4px 6px rgba(102, 126, 234, 0.1);';
      
      minifigCard.innerHTML = `
        <div class="card-body">
          <div class="row">
            <div class="col-md-3">
              <div style="text-align: center;">
                <img src="${minifig.img_url || 'placeholder.jpg'}" 
                     style="width: 120px; height: 120px; object-fit: contain; border-radius: 8px; border: 2px solid #667eea; padding: 10px; background: white;"
                     onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSIjRjVGNUY1Ii8+Cjx0ZXh0IHg9IjYwIiB5PSI2NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE2IiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5NaW5pZmlnPC90ZXh0Pgo8L3N2Zz4='">
                <div style="margin-top: 10px; font-weight: bold; color: #667eea;">${minifig.fig_num}</div>
                <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                  ${minifig.quantity} x
                </div>
                <div class="progress" style="height: 20px; margin-top: 10px;">
                  <div class="progress-bar" style="width: ${minifigCompletion}%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);">
                    ${minifigCompletion}%
                  </div>
                </div>
              </div>
            </div>
            
            <div class="col-md-9">
              <h6 style="color: #667eea; font-size: 1.1em; margin-bottom: 15px;">
                ${minifig.name}
              </h6>
              
              <div class="minifig-parts-list">
                ${minifigParts.length > 0 ? `
                  <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                    ${minifigParts.map(part => {
                      const inventoryQty = unifiedDataManager.getInventoryQuantity(part.part_num, part.color_id);
                      const isComplete = inventoryQty >= (part.quantity || 1);
                      
                      // ‚úÖ AJOUT : Masquer la pi√®ce de minifig si compl√®te ET filtre activ√©
                      if (hideCompleted && isComplete) {
                        return ''; // Ne pas afficher cette pi√®ce
                      }
                      
                      return `
                        <div class="parts-table-row ${isComplete ? 'completed minifig-completed' : ''}" data-minifig-id="${minifig.fig_num}" style="background: white; margin-bottom: 8px; padding: 10px; border-radius: 5px; border: 1px solid ${isComplete ? '#4caf50' : '#ddd'}; ${isComplete ? 'opacity: 0.6;' : ''}">
                          <div class="part-col-image">
                            <img src="${part.img_url}" 
                                 style="width: 50px; height: 50px; object-fit: contain; border-radius: 3px;"
                                 onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjRjVGNUY1Ii8+Cjwvc3ZnPgo='">
                          </div>
                          <div class="part-col-name">${part.name || 'Pi√®ce inconnue'}</div>
                          <div class="part-col-number">#${part.part_num}</div>
                          <div class="part-col-color">${part.color_name || 'Couleur inconnue'}</div>
                          <div class="part-col-controls">
                            <button class="btn btn-outline-secondary btn-sm" 
                                    data-action="minifig-decrement"
                                    data-part-num="${part.part_num}"
                                    data-color-id="${part.color_id}"
                                    data-minifig-id="${minifig.fig_num}"
                                    ${inventoryQty <= 0 ? 'disabled' : ''}>
                              <i class="bi bi-dash"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm" 
                                    data-action="minifig-increment"
                                    data-part-num="${part.part_num}"
                                    data-color-id="${part.color_id}"
                                    data-minifig-id="${minifig.fig_num}"
                                    ${inventoryQty >= (part.quantity || 1) ? 'disabled' : ''}>
                              <i class="bi bi-plus"></i>
                            </button>
                          </div>
                          <div class="part-col-counts">
                            <span class="quantity-display" id="minifig-qty-${minifig.fig_num}-${part.part_num}-${part.color_id}">
                              ${inventoryQty}/${part.quantity || 1}
                            </span>
                          </div>
                          <div class="part-col-all">
                            <input type="checkbox" 
                                   class="form-check-input minifig-part-checkbox" 
                                   data-minifig-id="${minifig.fig_num}"
                                   data-part-num="${part.part_num}"
                                   data-color-id="${part.color_id}"
                                   ${isComplete ? 'checked' : ''}>
                          </div>
                        </div>
                      `;
                    }).join('')}
                  </div>
                ` : '<p style="color: #666; font-style: italic;">Aucune pi√®ce d√©taill√©e disponible</p>'}
              </div>
            </div>
          </div>
        </div>
      `;
      
      minifigsSection.appendChild(minifigCard);
      
      if (isMinifigComplete) {
        minifigCard.classList.add('completed');
      }
    }

    container.appendChild(minifigsSection);
  }

  
  // ========================================
  // 2. SECTION PI√àCES NORMALES DU SET
  // ========================================
  if (normalParts.length > 0) {
    const normalPartsSection = document.createElement('div');
    normalPartsSection.innerHTML = `
      <h5 style="margin: 30px 0 20px 0; padding: 15px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
        <i class="bi bi-box-seam" style="font-size: 1.5em;"></i>
        <span>Pi√®ces du set (${normalParts.length})</span>
      </h5>
    `;
    container.appendChild(normalPartsSection);
    
    normalParts.forEach(part => {
      if (part.isSpare === true || part.isSpare === 1 || part.isSpare === 't' || part.isSpare === 'true') {
        console.warn(`‚ö†Ô∏è Spare part d√©tect√©e dans normalParts: ${part.partNum} (isSpare=${part.isSpare})`);
        return;
      }
      
      const isCompleted = part.quantityOwned >= part.quantity;
      if (hideCompleted && isCompleted) return; // ‚úÖ D√©j√† pr√©sent

      const item = document.createElement('div');
      item.className = `parts-table-row ${isCompleted ? 'completed' : ''}`;
      item.innerHTML = `
        <div class="part-col-image">
          <div id="part-img-${part.id}" style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; border: 1px solid #ddd; border-radius: 3px;">
            Chargement...
          </div>
        </div>
        <div class="part-col-name">
          <strong>${part.name || 'Nom en cours de chargement...'}</strong>
        </div>
        <div class="part-col-number">#${part.partNum}</div>
        <div class="part-col-color">${part.color || 'Couleur en cours de chargement...'}</div>
        <div class="part-col-controls">
          <button class="btn btn-outline-secondary btn-sm"
            data-action="decrement"
            data-set-number="${set.number}"
            data-part-id="${part.id}"
            data-part-num="${part.partNum}"
            data-color-id="${part.colorId}">
            <i class="bi bi-dash"></i>
          </button>
          <button class="btn btn-outline-secondary btn-sm"
            data-action="increment"
            data-set-number="${set.number}"
            data-part-id="${part.id}"
            data-part-num="${part.partNum}"
            data-color-id="${part.colorId}">
            <i class="bi bi-plus"></i>
          </button>
        </div>
        <div class="part-col-counts">
          <span class="quantity-display">${part.quantityOwned}/${part.quantity}</span>
        </div>
        <div class="part-col-all">
          <input type="checkbox" class="form-check-input all-checkbox" data-part-id="${part.id}" 
                 ${part.quantityOwned >= part.quantity ? 'checked' : ''}>
        </div>
      `;
      
      container.appendChild(item);
      
      const allCheckbox = item.querySelector('.all-checkbox');
      const decrementBtn = item.querySelector('[data-action="decrement"]');
      const incrementBtn = item.querySelector('[data-action="increment"]');
      const quantityDisplay = item.querySelector('.quantity-display');

      allCheckbox.addEventListener('change', async (e) => {
        if (e.target.checked) {
          part.quantityOwned = part.quantity;
        } else {
          part.quantityOwned = 0;
        }
        
        setManager.unifiedManager.updateSetPartQuantity(setNumber, part.partNum, part.colorId, part.quantityOwned);
        setManager.unifiedManager.saveUnifiedData();
        
        quantityDisplay.textContent = `${part.quantityOwned}/${part.quantity}`;
        decrementBtn.disabled = part.quantityOwned <= 0;
        incrementBtn.disabled = part.quantityOwned >= part.quantity;
        
        const isNowCompleted = part.quantityOwned >= part.quantity;
        item.className = `parts-table-row ${isNowCompleted ? 'completed' : ''}`;
        
        renderSetHeader(setNumber);
      });

      const partCacheKey = `${part.partNum}_${part.colorId}`;
      if (!loadedParts.has(partCacheKey)) {
        loadedParts.add(partCacheKey);
        loadPartImageOptimized(part.id, part.partNum, part.colorId);
      } else {
        const cachedUrl = partImageCache.get(partCacheKey);
        if (cachedUrl) {
          const imgContainer = document.getElementById(`part-img-${part.id}`);
          if (imgContainer) {
            imgContainer.innerHTML = `<img src="${cachedUrl}" alt="${part.name}" style="width: 60px; height: 60px; object-fit: contain;">`;
          }
        }
      }
    });
  }
  
  // ========================================
  // 3. SECTION SPARE PARTS (inchang√©e)
  // ========================================
  if (spareParts.length > 0) {
  const sparePartsSection = document.createElement('div');
  sparePartsSection.innerHTML = `
    <h5 style="margin: 30px 0 20px 0; padding: 15px; background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%); color: white; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
      <i class="bi bi-plus-circle" style="font-size: 1.5em;"></i>
      <span>Pi√®ces suppl√©mentaires (${spareParts.length})</span>
    </h5>
  `;
  container.appendChild(sparePartsSection);
  
  spareParts.forEach(part => {
    // ‚úÖ CORRECTION : Trouver la pi√®ce normale correspondante pour l'image
    const correspondingNormalPart = normalParts.find(
      p => p.partNum === part.partNum && p.colorId === part.colorId
    );
    
    const imageUrl = correspondingNormalPart?.imageUrl || part.imageUrl || '';
    
    const item = document.createElement('div');
    item.className = 'parts-table-row spare-part';
    item.innerHTML = `
      <div class="part-col-image">
        <div id="spare-part-img-${part.id}" style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; border: 1px solid #ddd; border-radius: 3px;">
          ${imageUrl ? 
            `<img src="${imageUrl}" alt="${part.name}" style="width: 60px; height: 60px; object-fit: contain;" onerror="this.style.display='none'; this.parentNode.innerHTML='<div style=\\'width: 60px; height: 60px; background: #f0f0f0; border: 1px dashed #ddd; border-radius: 3px; display: flex; align-items: center; justify-content: center;\\'>üì¶</div>'">` 
            : 
            'Chargement...'
          }
        </div>
      </div>
      <div class="part-col-name">
        <strong>${part.name}</strong>
        <span class="badge bg-warning ms-1">Spare</span>
      </div>
      <div class="part-col-number">#${part.partNum}</div>
      <div class="part-col-color">${part.color}</div>
      <div class="part-col-controls">-</div>
      <div class="part-col-counts">
        <span class="text-muted">${part.quantity}</span>
      </div>
      <div class="part-col-all">-</div>
    `;
    container.appendChild(item);
    
    // ‚úÖ Si pas d'image, charger depuis le cache ou IndexedDB
    if (!imageUrl) {
      const partCacheKey = `${part.partNum}_${part.colorId}`;
      
      // V√©rifier d'abord le cache
      if (partImageCache.has(partCacheKey)) {
        const cachedUrl = partImageCache.get(partCacheKey);
        const imgContainer = document.getElementById(`spare-part-img-${part.id}`);
        if (imgContainer) {
          imgContainer.innerHTML = `<img src="${cachedUrl}" alt="${part.name}" style="width: 60px; height: 60px; object-fit: contain;">`;
        }
      } else {
        // Charger l'image
        loadPartImageOptimized(part.id, part.partNum, part.colorId, true);
      }
    }
  });
}
  debugGroupEnd();
}

// Fonction optimis√©e pour charger les images de pi√®ces
async function loadPartImageOptimized(partId, partNum, colorId, isSpare = false) {
  const cacheKey = `${partNum}_${colorId}`;
  const containerId = isSpare ? `spare-part-img-${partId}` : `part-img-${partId}`;
  
  // V√©rifier le cache d'abord
  if (partImageCache.has(cacheKey)) {
    const cachedUrl = partImageCache.get(cacheKey);
    const imgContainer = document.getElementById(containerId);
    if (imgContainer) {
      imgContainer.innerHTML = `<img src="${cachedUrl}" alt="Pi√®ce ${partNum}" style="width: 60px; height: 60px; object-fit: contain;">`;
    }
    return;
  }

  let imageUrl = '';
  
  // Essayer IndexedDB d'abord
  if (legoDb) {
    try {
      const inventoryParts = await legoDb.getDataByIndex('inventory_parts', 'part_num', partNum);
      const matchingPart = inventoryParts.find(ip => ip.color_id === colorId);
      if (matchingPart && matchingPart.img_url) {
        imageUrl = matchingPart.img_url;
      }
    } catch (error) {
      console.warn('Erreur r√©cup√©ration image depuis IndexedDB:', error);
    }
  }
  
  // Fallback vers l'URL g√©n√©rique
  if (!imageUrl) {
    imageUrl = `https://cdn.rebrickable.com/media/parts/elements/${partNum}.jpg`;
  }
  
  // Tester et afficher l'image
  const img = new Image();
  img.onload = () => {
    const imgContainer = document.getElementById(containerId);
    if (imgContainer) {
      imgContainer.innerHTML = `<img src="${imageUrl}" alt="Pi√®ce ${partNum}" style="width: 60px; height: 60px; object-fit: contain;">`;
      // Mettre en cache
      partImageCache.set(cacheKey, imageUrl);
    }
  };
  img.onerror = () => {
    const fallbackUrl = `https://cdn.rebrickable.com/media/parts/elements/${partNum}.jpg`;
    const fallbackImg = new Image();
    fallbackImg.onload = () => {
      const imgContainer = document.getElementById(containerId);
      if (imgContainer) {
        imgContainer.innerHTML = `<img src="${fallbackUrl}" alt="Pi√®ce ${partNum}" style="width: 60px; height: 60px; object-fit: contain;">`;
        partImageCache.set(cacheKey, fallbackUrl);
      }
    };
    fallbackImg.onerror = () => {
      const imgContainer = document.getElementById(containerId);
      if (imgContainer) {
        imgContainer.innerHTML = `<div style="width: 60px; height: 60px; background: #f0f0f0; border: 1px solid #ddd; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 0.7em; color: #666;">üì¶</div>`;
      }
    };
    fallbackImg.src = fallbackUrl;
  };
  img.src = imageUrl;
}

// Fonction de debug temporaire
function debugImportData(data) {
  console.group('üîç DEBUG IMPORT DATA');
  console.log('Nombre de sets:', data.sets.length);
  data.sets.forEach((set, i) => {
    console.log(`Set ${i}:`, {
      number: set.number,
      name: set.name,
      parts: set.parts?.length || 0,
      imageUrl: set.imageUrl
    });
  });
  console.groupEnd();
}

// Modifier handleFileImport pour inclure le debug
async function handleFileImport(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const text = await file.text();
    debug('Fichier import√© (premiers 500 caract√®res):', text.substring(0, 500));
    
    const data = JSON.parse(text);
    debugImportData(data);
    
    if (!data.sets || !Array.isArray(data.sets)) {
      throw new Error('Format de fichier invalide: propri√©t√© "sets" manquante');
    }
    
    // V√©rifier la structure des sets
    data.sets.forEach((set, index) => {
      if (!set.number || !set.name) {
        throw new Error(`Set invalide √† l'index ${index}: num√©ro ou nom manquant`);
      }
    });
    
    await showImportPreview(data.sets);
  } catch (error) {
    console.error('Erreur import:', error);
    showToast('Erreur lors de l\'import: ' + error.message, 'error');
  }
  
  e.target.value = '';
}


   function handleSetImageError(img, setNumber) {
  const fallbacks = [
    `https://cdn.rebrickable.com/media/sets/${setNumber}.jpg`,
    `https://cdn.rebrickable.com/media/sets/${setNumber}/set_img.jpg`,
    'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjRjVGNUY1Ii8+CjxyZWN0IHg9IjEiIHk9IjEiIHdpZHRoPSIyOCIgaGVpZ2h0PSIyOCIgc3Ryb2tlPSIjREREIi8+Cjx0ZXh0IHg9IjE1IiB5PSIyMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjgiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlNldDwvdGV4dD4KPHN2Zz4K'
  ];
  
  const currentIndex = img.dataset.fallbackIndex ? parseInt(img.dataset.fallbackIndex) : 0;
  
  if (currentIndex < fallbacks.length - 1) {
    img.dataset.fallbackIndex = currentIndex + 1;
    img.src = fallbacks[currentIndex + 1];
  }
}

// Exposer globalement
window.handleSetImageError = handleSetImageError;

function renderMissingParts() {
  const container = document.getElementById('missing-parts-list');
  const missingParts = setManager.getMissingPartsGroupedByPart();

  if (missingParts.length === 0) {
    container.innerHTML = `
      <div class="text-center py-5">
        <i class="bi bi-check-circle display-1 text-success"></i>
        <h3 class="mt-3 text-success">F√©licitations !</h3>
        <p class="text-muted">Aucune pi√®ce manquante dans votre collection</p>
      </div>
    `;
    return;
  }

  container.innerHTML = `
    <div class="table-responsive">
      <table class="table table-bordered align-middle">
        <thead class="table-light">
          <tr>
            <th>Image</th>
            <th>Pi√®ce</th>
            <th>Couleur</th>
            <th>Set</th>
            <th>Manquant</th>
            <th>Disponible</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="missing-parts-table-body"></tbody>
      </table>
    </div>
  `;

  const tbody = document.getElementById('missing-parts-table-body');
  
  missingParts.forEach(async (part) => {
    // R√©cup√©rer la quantit√© disponible depuis l'inventaire unifi√©
    const availableQty = await getAvailableQuantityFromBulk(part.partNum, part.colorId);
    
    // Cr√©er une ligne par set, mais grouper visuellement
    part.sets.forEach((setInfo, setIndex) => {
      const row = document.createElement('tr');
      
      row.innerHTML = `
        <td ${setIndex === 0 ? `rowspan="${part.sets.length}"` : 'style="display:none;"'}>
          <div id="missing-part-img-${part.partNum}-${part.colorId}" style="width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: #f0f0f0;">
            <div class="spinner-border spinner-border-sm" role="status"></div>
          </div>
        </td>
        <td ${setIndex === 0 ? `rowspan="${part.sets.length}"` : 'style="display:none;"'}>
          <strong>${part.name}</strong><br>
          <small>#${part.partNum}</small>
        </td>
        <td ${setIndex === 0 ? `rowspan="${part.sets.length}"` : 'style="display:none;"'}>
          ${part.color}
        </td>
        <td>
          <div class="d-flex align-items-center">
<img src="${setInfo.imageUrl || `https://cdn.rebrickable.com/media/sets/${setInfo.number}-1.jpg`}" 
     alt="${setInfo.name}" style="height:30px;margin-right:8px"
     onerror="handleSetImageError(this, '${setInfo.number}')">
              <div>${setInfo.name}</div>
              <small>#${setInfo.number}</small>
            </div>
          </div>
        </td>
        <td>
          <span id="missing-qty-${part.partNum}-${part.colorId}-${setInfo.number}">${setInfo.missing}</span>
        </td>
        <td ${setIndex === 0 ? `rowspan="${part.sets.length}"` : 'style="display:none;"'}>
          <span id="available-qty-${part.partNum}-${part.colorId}">${availableQty}</span>
        </td>
        <td>
          <div class="btn-group btn-group-sm">
            <button class="btn btn-outline-success" 
                    onclick="transferPartToSetFixed('${part.partNum}', ${part.colorId}, '${setInfo.number}', 1)"
                    ${availableQty <= 0 ? 'disabled' : ''}>+</button>
            <button class="btn btn-outline-danger" 
                    onclick="transferPartToSetFixed('${part.partNum}', ${part.colorId}, '${setInfo.number}', -1)"
                    ${setInfo.missing <= 0 ? 'disabled' : ''}>-</button>
          </div>
        </td>
      `;
      tbody.appendChild(row);
     // Charger correctement l‚Äôimage du set avec la fonction existante
const imgEl = row.querySelector(`img[alt="${setInfo.name}"]`);
if (imgEl) {
  const apiKey = localStorage.getItem('rebrickable_api_key');
  loadSetImageWithAPI(imgEl, setInfo.number, setInfo.imageUrl, apiKey, false);
} 
    });

    // Charger l'image une seule fois pour toutes les lignes de cette pi√®ce
    setTimeout(async () => {
      const imgContainer = document.getElementById(`missing-part-img-${part.partNum}-${part.colorId}`);
      if (imgContainer && legoDb) {
        try {
          const inventoryParts = await legoDb.getDataByIndex('inventory_parts', 'part_num', part.partNum);
          const matchingPart = inventoryParts.find(ip => ip.color_id === part.colorId);
          let imageUrl = matchingPart?.img_url || `https://cdn.rebrickable.com/media/parts/elements/${part.partNum}.jpg`;
          
          const img = new Image();
          img.onload = () => {
            imgContainer.innerHTML = `<img src="${imageUrl}" alt="${part.name}" style="width: 40px; height: 40px; object-fit: contain;">`;
          };
          img.onerror = () => {
            imgContainer.innerHTML = `
              <div style="width: 40px; height: 40px; background: #f8f9fa; border: 1px dashed #dee2e6; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.6em; color: #6c757d;">
                <i class="bi bi-image"></i>
                <div style="font-size: 0.5em;">#${part.partNum.substring(0,6)}</div>
              </div>
            `;
          };
          img.src = imageUrl;
        } catch (error) {
          imgContainer.innerHTML = `
            <div style="width: 40px; height: 40px; background: #f8f9fa; border: 1px dashed #dee2e6; border-radius: 3px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.6em; color: #6c757d;">
              <i class="bi bi-image"></i>
              <div style="font-size: 0.5em;">#${part.partNum.substring(0,6)}</div>
            </div>
          `;
        }
      }
    }, 100);
  });
}

   // Fonction pour r√©cup√©rer la quantit√© disponible depuis l'inventaire en vrac
async function getAvailableQuantityFromBulk(partNum, colorId) {
  try {
    if (unifiedDataManager) {
      const item = unifiedDataManager.currentData.inventory.find(
        item => item.part_num === partNum && item.color_id === colorId
      );
      return item ? item.quantity : 0;
    }
    return 0;
  } catch (error) {
    console.error('Erreur lecture inventaire:', error);
    return 0;
  }
}

// Fonction corrig√©e pour les transferts depuis les pi√®ces manquantes
async function transferPartToSetFixed(partNum, colorId, setNumber, quantity) {
  try {
    if (quantity > 0) {
      // Transf√©rer DE l'inventaire VERS le set
      const success = await unifiedDataManager.transferPartToSet(partNum, colorId, setNumber, quantity);
      if (success) {
        // Mettre √† jour aussi dans setManager local
        const set = setManager.getSet(setNumber);
        if (set) {
          const part = set.parts.find(p => p.partNum === partNum && p.colorId === colorId);
          if (part) {
            part.quantityOwned = Math.min(part.quantity, part.quantityOwned + quantity);
          }
        }
        showToast(`${quantity} pi√®ce(s) transf√©r√©e(s) vers le set ${setNumber}`, 'success');
      }
    } else {
      // Retirer DU set VERS l'inventaire
      const set = setManager.getSet(setNumber);
      if (set) {
        const part = set.parts.find(p => p.partNum === partNum && p.colorId === colorId);
        if (part && part.quantityOwned > 0) {
          part.quantityOwned = Math.max(0, part.quantityOwned + quantity);
          
          const currentInventoryQty = unifiedDataManager.getInventoryQuantity(partNum, colorId);
          unifiedDataManager.updateInventory(partNum, colorId, part.color || 'Couleur inconnue', currentInventoryQty - quantity, 'Unknown');
          unifiedDataManager.updateSetPartQuantity(setNumber, partNum, colorId, part.quantityOwned);
          
          await unifiedDataManager.saveUnifiedData();
          showToast(`${-quantity} pi√®ce(s) retir√©e(s) du set ${setNumber}`, 'success');
        }
      }
    }   
  } catch (error) {
    console.error('Erreur transfert:', error);
    showToast('Erreur lors du transfert: ' + error.message, 'error');
  }
  updateMissingPartsDisplay(partNum, colorId, setNumber);
}

   function updateMissingPartsDisplay(partNum, colorId, setNumber) {
  // Mettre √† jour la quantit√© disponible dans l'inventaire
  const availableQty = unifiedDataManager.getInventoryQuantity(partNum, colorId);
  const availableElement = document.getElementById(`available-qty-${partNum}-${colorId}`);
  if (availableElement) {
    availableElement.textContent = availableQty;
  }
  
  // Mettre √† jour la quantit√© manquante pour ce set sp√©cifique
  const set = setManager.getSet(setNumber);
  if (set) {
    const part = set.parts.find(p => p.partNum === partNum && p.colorId === colorId);
    if (part) {
      const missingQty = Math.max(0, part.quantity - part.quantityOwned);
      const missingElement = document.getElementById(`missing-qty-${partNum}-${colorId}-${setNumber}`);
      
      if (missingQty === 0) {
        // Supprimer cette ligne du tableau si plus de pi√®ce manquante
        const row = missingElement?.closest('tr');
        if (row) {
          // V√©rifier si c'√©tait la derni√®re ligne pour cette pi√®ce
          const allRowsForPart = document.querySelectorAll(`[id^="missing-qty-${partNum}-${colorId}-"]`);
          
          if (allRowsForPart.length === 1) {
            // C'√©tait la derni√®re ligne, supprimer compl√®tement cette pi√®ce
            // Trouver toutes les lignes avec rowspan pour cette pi√®ce
            const partRows = Array.from(document.querySelectorAll(`tr`)).filter(r => 
              r.innerHTML.includes(`missing-qty-${partNum}-${colorId}`)
            );
            partRows.forEach(r => r.remove());
          } else {
            // Il reste d'autres sets avec cette pi√®ce manquante, supprimer seulement cette ligne
            row.remove();
            
            // Si on supprime la premi√®re ligne (avec les rowspan), il faut reporter les rowspan
            const firstRowForPart = document.querySelector(`[id="missing-part-img-${partNum}-${colorId}"]`)?.closest('tr');
            if (!firstRowForPart) {
              const nextRow = document.querySelector(`[id^="missing-qty-${partNum}-${colorId}-"]`)?.closest('tr');
              if (nextRow) {
                // R√©cup√©rer le nombre de lignes restantes pour cette pi√®ce
                const remainingRows = document.querySelectorAll(`[id^="missing-qty-${partNum}-${colorId}-"]`).length;
                
                // Ajouter les cellules avec rowspan √† la nouvelle premi√®re ligne
                const part = setManager.getMissingPartsGroupedByPart().find(p => 
                  p.partNum === partNum && p.colorId === colorId
                );
                
                if (part) {
                  nextRow.insertAdjacentHTML('afterbegin', `
                    <td rowspan="${remainingRows}">
                      <div id="missing-part-img-${partNum}-${colorId}" style="width: 40px; height: 40px;">
                        <img src="${part.imageUrl}" style="width: 40px; height: 40px; object-fit: contain;">
                      </div>
                    </td>
                    <td rowspan="${remainingRows}">
                      <strong>${part.name}</strong><br><small>#${part.partNum}</small>
                    </td>
                    <td rowspan="${remainingRows}">${part.color}</td>
                    <td rowspan="${remainingRows}">
                      <span id="available-qty-${partNum}-${colorId}">${availableQty}</span>
                    </td>
                  `);
                }
              }
            }
          }
          
          // V√©rifier s'il ne reste plus aucune pi√®ce manquante
          const remainingMissingParts = document.querySelectorAll('[id^="missing-qty-"]');
          if (remainingMissingParts.length === 0) {
            // Recharger compl√®tement avec le message de f√©licitations
            renderMissingParts();
          }
        }
      } else {
        // Mettre √† jour seulement le nombre
        if (missingElement) {
          missingElement.textContent = missingQty;
        }
      }
      
      // Mettre √† jour l'√©tat des boutons
      const plusBtn = document.querySelector(`button[onclick*="transferPartToSetFixed('${partNum}', ${colorId}, '${setNumber}', 1)"]`);
      const minusBtn = document.querySelector(`button[onclick*="transferPartToSetFixed('${partNum}', ${colorId}, '${setNumber}', -1)"]`);
      
      if (plusBtn) {
        plusBtn.disabled = availableQty <= 0;
      }
      if (minusBtn) {
        minusBtn.disabled = missingQty <= 0;
      }
    }
  }
}

   // Ajoutez cette fonction globale:
function showLoading(show) {
  const btn = document.getElementById('add-set-btn');
  if (show) {
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Ajout...';
    
    // Cr√©er un overlay de charnement pour l'import
    if (!document.getElementById('loading-overlay')) {
      const overlay = document.createElement('div');
      overlay.id = 'loading-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      overlay.innerHTML = `
        <div class="spinner-border text-light" style="width: 3rem; height: 3rem;"></div>
      `;
      document.body.appendChild(overlay);
    }
  } else {
    btn.disabled = false;
    btn.innerHTML = 'Ajouter';
    
    // Supprimer l'overlay
    const overlay = document.getElementById('loading-overlay');
    if (overlay) overlay.remove();
  }
}

function debugImport(importSets, selectedSets) {
  console.group('üîç DEBUG IMPORT');
  console.log('Sets dans le fichier:', importSets.length);
  console.log('Sets s√©lectionn√©s:', selectedSets.length);
  console.log('Sets avant import:', setManager.sets.length);
  console.log('Sets s√©lectionn√©s:', selectedSets.map(s => s.number));
  console.groupEnd();}

async function showImportPreview(importSets) {
  const existingSets = setManager.sets.map(s => s.number);
  
  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.innerHTML = `
    <div class="modal import-modal">
      <h4 class="mb-3">Pr√©visualisation de l'import</h4>
      <p>S√©lectionnez les sets √† importer :</p>
      <div class="import-preview-list" style="max-height: 400px; overflow-y: auto;">
        ${importSets.map((set, index) => {
          const exists = existingSets.includes(set.number);
          const totalParts = set.parts ? set.parts.length : 0;
          const ownedParts = set.parts ? set.parts.reduce((sum, p) => sum + (p.quantityOwned || 0), 0) : 0;
          
          return `
            <div class="import-set-item ${exists ? 'existing-set' : ''}" style="display: flex; align-items: center; padding: 10px; border: 1px solid #ddd; margin-bottom: 10px; border-radius: 5px;">
              <input type="checkbox" id="import-${index}" ${!exists ? 'checked' : ''} style="margin-right: 10px;">
              <img src="${set.imageUrl || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjRjVGNUY1Ii8+Cjx0ZXh0IHg9IjI1IiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5TZXQ8L3RleHQ+Cjwvc3ZnPgo='}" 
                   class="suggestion-img" alt="${set.name}"
                   onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjRjVGNUY1Ii8+Cjx0ZXh0IHg9IjI1IiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5TZXQ8L3RleHQ+Cjwvc3ZnPgo='">
              <div style="flex-grow: 1;">
                <strong>${set.name}</strong><br>
                <small>#${set.number} ‚Ä¢ ${totalParts} pi√®ces ‚Ä¢ ${ownedParts} poss√©d√©es</small>
                ${exists ? '<br><span style="color: #ff9800; font-weight: bold;">‚ö† D√©j√† dans votre collection</span>' : ''}
              </div>
            </div>
          `;
        }).join('')}
      </div>
      <div class="mt-3 d-flex justify-content-end gap-2">
        <button class="btn btn-secondary" onclick="closeImportModal(this)">Annuler</button>
<button class="btn btn-primary import-confirm-btn">Importer s√©lectionn√©s</button>
      </div>
    </div>
  `;
 modal.querySelector('.import-confirm-btn')
  .addEventListener('click', confirmImport); 
  document.body.appendChild(modal);
  
  // Stocker les donn√©es globalement pour confirmImport
  window.importModalData = {
    modal: modal,
    importSets: importSets
  };
}

// Fonction pour fermer le modal
function closeImportModal(btn) {
  const modal = btn.closest('.modal-overlay');
  if (modal) {
    modal.remove();
    // Nettoyer les donn√©es globales
    delete window.importModalData;
  }
}

async function confirmImport() {
  if (!window.importModalData) {
    showToast('Erreur: donn√©es d\'import non disponibles', 'error');
    return;
  }
  
  const { modal, importSets } = window.importModalData;
  const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
  const selectedSets = Array.from(checkboxes).map(cb => {
    const index = parseInt(cb.id.replace('import-', ''));
    return importSets[index];
  });
  
  if (selectedSets.length === 0) {
    showToast('Aucun set s√©lectionn√©', 'warning');
    return;
  }

  try {
    // Fermer le modal d'abord
    modal.remove();
    delete window.importModalData;
    
    showLoading(true);
    
    debug('üîß D√©but de l\'import de', selectedSets.length, 'sets');
    
    let importedCount = 0;
    
    for (const importSet of selectedSets) {
      debug('üì¶ Traitement du set:', importSet.number);
      
      const existingIndex = setManager.sets.findIndex(s => s.number === importSet.number);
      
      if (existingIndex >= 0) {
        // Remplacer le set existant
        debug('üîÑ Remplacement du set existant:', importSet.number);
        setManager.sets[existingIndex] = importSet;
        importedCount++;
      } else {
        // Ajouter le nouveau set
        debug('‚ûï Ajout du nouveau set:', importSet.number);
        setManager.sets.push(importSet);
        importedCount++;
      }
    }
    
    debug('üíæ Sauvegarde dans unified data...');
    
    // Sauvegarder dans le format unifi√©
    await setManager.saveToUnified();
    
    debug('‚úÖ Import termin√©, rechargement de l\'affichage...');
    
    // Recharger depuis le format unifi√© pour s'assurer de la coh√©rence
    setManager.loadFromUnified();
    
    // Recharger l'affichage
    showHomeView();
    showToast(`${importedCount} set(s) import√©(s) avec succ√®s`, 'success');
    
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'import:', error);
    showToast('Erreur lors de l\'import: ' + error.message, 'error');
  } finally {
    showLoading(false);
    debug('üèÅ Import process termin√©');
  }
}

   // ================================
   // GESTION DES RECHERCHES ET SUGGESTIONS
   // ================================
  let searchTimeout = null;
   async function handleSearchInput(e) {
     const query = e.target.value.trim();
     
     clearTimeout(searchTimeout);
     
     if (query.length < 2) {
       clearSuggestions();
       return;
     }
     
     searchTimeout = setTimeout(async () => {
       try {
         // Essayer d'abord avec l'API
         const response = await fetch(`https://rebrickable.com/api/v3/lego/sets/?search=${encodeURIComponent(query)}&page_size=5`, {
           headers: { Authorization: `key ${setManager.apiKey}` }
         });
         
         if (response.ok) {
           const data = await response.json();
           showSuggestions(data.results);
         } else {
           // Fallback vers des sets populaires
           const suggestions = getPopularSets().filter(set => 
             set.name.toLowerCase().includes(query.toLowerCase()) ||
             set.number.includes(query)
           );
           showSuggestions(suggestions.slice(0, 5));
         }
       } catch (error) {
         console.error('Erreur recherche:', error);
         const suggestions = getPopularSets().filter(set => 
           set.name.toLowerCase().includes(query.toLowerCase()) ||
           set.number.includes(query)
         );
         showSuggestions(suggestions.slice(0, 5));
       }
     }, 300);
   }

   function getPopularSets() {
     return [
       { set_num: '10280-1', name: 'Flower Bouquet', set_img_url: 'https://cdn.rebrickable.com/media/sets/10280-1/91015/set_img.jpg' },
       { set_num: '21325-1', name: 'Medieval Blacksmith', set_img_url: 'https://cdn.rebrickable.com/media/sets/21325-1/91016/set_img.jpg' },
       { set_num: '10307-1', name: 'Eiffel Tower', set_img_url: 'https://cdn.rebrickable.com/media/sets/10307-1/91017/set_img.jpg' },
       { set_num: '76989-1', name: 'Horizon Forbidden West: Tallneck', set_img_url: 'https://cdn.rebrickable.com/media/sets/76989-1/91018/set_img.jpg' },
       { set_num: '10281-1', name: 'Bonsai Tree', set_img_url: 'https://cdn.rebrickable.com/media/sets/10281-1/91019/set_img.jpg' }
     ];
   }

   function showSuggestions(suggestions) {
     const container = document.getElementById('suggestions-container');
     
     if (suggestions.length === 0) {
       clearSuggestions();
       return;
     }
     
     container.innerHTML = suggestions.map(set => `
       <div class="suggestion-item" data-set-number="${set.set_num}">
         <img src="${set.set_img_url || 'https://via.placeholder.com/50x50?text=Set'}" 
              class="suggestion-img" alt="${set.name}"
              onerror="this.src='https://via.placeholder.com/50x50?text=Set'">
         <div>
           <strong>${set.name}</strong><br>
           <small>#${set.set_num}</small>
         </div>
       </div>
     `).join('');
     
     container.querySelectorAll('.suggestion-item').forEach(item => {
       item.addEventListener('click', () => {
         document.getElementById('set-number-input').value = item.dataset.setNumber;
         clearSuggestions();
         handleAddSet();
       });
     });
   }

   function clearSuggestions() {
     document.getElementById('suggestions-container').innerHTML = '';
   }

   // ================================
   // FONCTIONS D'ACTION
   // ================================

   function isValidSetNumber(setNumber) {
  // Formats accept√©s : 10280, 10280-1, 75400, etc.
  const setRegex = /^[a-zA-Z0-9]+(-[0-9]+)?$/;
  return setRegex.test(setNumber) && setNumber.length >= 3;
}

   async function handleAddSet() {
     const input = document.getElementById('set-number-input');
     const setNumber = input.value.trim();
     
     if (!setNumber) {
       showToast('Veuillez entrer un num√©ro de set', 'warning');
       return;
     }
     
       // ‚úÖ CORRECTION : Validation du format
  if (!isValidSetNumber(setNumber)) {
    showToast('Format de num√©ro de set invalide. Exemples: "10280" ou "10280-1"', 'warning');
    return;
  }

     try {
       showLoading(true);

    // AJOUT : Attendre que setManager soit pr√™t
    if (setManager) {
      await setManager.waitForReady();
    }
       
       const legoSet = await setManager.fetchSetData(setNumber);

       // Sauvegarde apr√®s ajout
       //storageManager.saveLocal();

       input.value = '';
       clearSuggestions();
       showSetDetailView(legoSet.number);
       showToast(`Set ${legoSet.name} ajout√© avec succ√®s`, 'success');
     } catch (error) {
       showToast(error.message, 'error');
     } finally {
       showLoading(false);
     }
   }

   //function showLoading(show) {
     //const btn = document.getElementById('add-set-btn');
     //if (show) {
      // btn.disabled = true;
      // btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Ajout...';
     //} else {
      // btn.disabled = false;
       //btn.innerHTML = 'Ajouter';
     //}
   //}

   function handleExport(format) {
     try {
       let content, filename, mimeType;
       
       switch (format) {
         case 'json':
           content = JSON.stringify({ sets: setManager.sets }, null, 2);
           filename = 'lego_sets_export.json';
           mimeType = 'application/json';
           break;
           
         case 'csv':
           const missingParts = setManager.getMissingPartsGroupedByPart();
           const csvHeaders = 'Part Number,Part Name,Color,Total Missing\n';
           const csvRows = missingParts.map(p => 
             `"${p.partNum}","${p.name}","${p.color}",${p.totalMissing}`
           ).join('\n');
           content = csvHeaders + csvRows;
           filename = 'missing_parts.csv';
           mimeType = 'text/csv';
           break;
           
         case 'xml':
           content = generateXML(setManager.sets);
           filename = 'lego_sets_export.xml';
           mimeType = 'application/xml';
           break;
       }
       
       const blob = new Blob([content], { type: mimeType });
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = filename;
       a.click();
       URL.revokeObjectURL(url);
       
       showToast(`Export ${format.toUpperCase()} termin√©`, 'success');
     } catch (error) {
       showToast('Erreur lors de l\'export: ' + error.message, 'error');
     }
   }

   function generateXML(sets) {
     let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<sets>\n';
     
     sets.forEach(set => {
       xml += `  <set number="${set.number}" name="${escapeXml(set.name)}">\n`;
       set.parts.forEach(part => {
         xml += `    <part num="${part.partNum}" name="${escapeXml(part.name)}" color="${escapeXml(part.color)}" needed="${part.quantity}" owned="${part.quantityOwned}" />\n`;
       });
       xml += '  </set>\n';
     });
     
     xml += '</sets>';
     return xml;
   }

   function escapeXml(text) {
     return text.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
   }

   // ================================
   // FONCTIONS UTILITAIRES
   // ================================
   function toggleDarkMode() {
     isDarkMode = !isDarkMode;
     document.body.classList.toggle('dark-mode', isDarkMode);
     localStorage.setItem('darkMode', isDarkMode);
     
     const icon = document.getElementById('toggle-darkmode');
     icon.innerHTML = isDarkMode ? '<i class="bi bi-sun-fill"></i>' : '<i class="bi bi-moon-fill"></i>';
   }

   // ================================
   // SYST√àME DE NOTIFICATIONS
   // ================================
   function showToast(message, type = 'info') {
     const toastContainer = document.querySelector('.toast-container');
     
     const toast = document.createElement('div');
     toast.className = `toast align-items-center text-white bg-${type === 'error' ? 'danger' : type} border-0`;
     toast.setAttribute('role', 'alert');
     toast.innerHTML = `
       <div class="d-flex">
         <div class="toast-body">${message}</div>
         <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
       </div>
     `;
     
     toastContainer.appendChild(toast);
     
     const bsToast = new bootstrap.Toast(toast);
     bsToast.show();
     
     toast.addEventListener('hidden.bs.toast', () => {
       toast.remove();
     });
   }

   // ================================
   // NAVIGATION
   // ================================
   function goToMenu() {
  if (unifiedDataManager) {
    unifiedDataManager.saveUnifiedData();
  }
  navigateTo('menu.html');
}

   // Exposer les fonctions n√©cessaires globalement
   window.goToMenu = goToMenu;

   // Expose a global async function for transferring parts
   window.transferPartToSetFixed = transferPartToSetFixed;
   window.handleMinifigPartAction = handleMinifigPartAction; // ‚úÖ AJOUT
   window.handleMinifigPartCheckbox = handleMinifigPartCheckbox; // ‚úÖ AJOUT

   </script>
   <!-- SERVICE WORKER -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('‚úÖ Service Worker enregistr√©', reg.scope))
      .catch(err => console.error('‚ùå Erreur Service Worker:', err));
  });
}
</script>
<script src="./install-prompt.js"></script>
</body>
</html>